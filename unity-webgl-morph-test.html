<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Unity WebGL Morph Test</title>
    <style>
        body { margin: 0; background: #111; color: white; font-family: Arial; }
        .container { display: flex; height: 100vh; }
        .viewer { flex: 1; position: relative; background: #333; }
        .controls { width: 300px; padding: 20px; background: #222; overflow-y: auto; }
        .btn { 
            display: block; width: 100%; margin: 3px 0; padding: 10px; 
            background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; 
        }
        .btn:hover { background: #666; }
        .btn.active { background: #ff6b00; color: white; font-weight: bold; }
        .status { padding: 12px; background: #333; margin: 12px 0; border-radius: 4px; }
        .section { margin: 15px 0; }
        .section h3 { color: #fff; margin: 8px 0; border-bottom: 1px solid #444; padding-bottom: 4px; }
        .unity-placeholder { 
            width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
            background: linear-gradient(135deg, #ff6b00, #ffa500);
            color: white; font-size: 24px; font-weight: bold;
        }
        .bridge-status { font-size: 12px; color: #aaa; background: #111; padding: 8px; border-radius: 4px; margin: 8px 0; }
        .intensity-control { margin: 12px 0; }
        .intensity-slider { width: 100%; }
        .morph-mapping { font-size: 10px; color: #888; margin: 2px 0; }
        .test-info { background: #1a1a1a; padding: 10px; border-radius: 4px; margin: 10px 0; font-size: 12px; }
        .unity-controls { margin: 15px 0; }
        .unity-btn { background: #ff6b00; margin: 5px 0; }
        .unity-btn:hover { background: #e55a00; }
    </style>
</head>
<body>
    <div class="container">
        <div class="viewer">
            <div class="unity-placeholder" id="unity-container">
                <div style="text-align: center;">
                    <div style="font-size: 36px; margin-bottom: 20px;">🎮</div>
                    <div>Unity WebGL Build Area</div>
                    <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">
                        This would contain your Unity WebGL build<br>
                        Currently showing simulated Unity interface
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="status" id="status">Unity WebGL Morph Bridge Ready</div>
            
            <div class="unity-controls">
                <button class="btn unity-btn" onclick="initUnityBridge()">🔗 Initialize Unity Bridge</button>
                <button class="btn unity-btn" onclick="loadUnityAvatar()">👤 Load Unity Avatar</button>
                <button class="btn unity-btn" onclick="runUnityAutoTest()">🚀 Test All Visemes</button>
            </div>
            
            <div class="intensity-control">
                <label>Unity Intensity: <span id="unity-intensity-value">0.8</span></label>
                <input type="range" class="intensity-slider" id="unity-intensity" min="0" max="1" step="0.1" value="0.8" oninput="updateUnityIntensity(this.value)">
            </div>
            
            <div class="section">
                <h3>🎭 Unity WebGL Visemes</h3>
                <div id="unity-viseme-controls"></div>
            </div>
            
            <div class="section">
                <h3>🔗 Bridge Status</h3>
                <div class="bridge-status" id="bridge-status">Bridge not initialized</div>
            </div>
            
            <div class="section">
                <h3>📊 Unity BlendShapes</h3>
                <div class="test-info" id="unity-morphs-info">Unity avatar not loaded</div>
            </div>
        </div>
    </div>

    <script>
        let unityBridgeInitialized = false;
        let unityAvatarLoaded = false;
        let unityCurrentIntensity = 0.8;
        let simulatedUnityMorphs = {};

        // Unity-specific morph mappings (BlendShape names often differ)
        const UNITY_MORPH_MAPPINGS = {
            'sil': {},
            'aa': { 
                'mouthOpen': 0.85, 
                'jawOpen': 0.75, 
                'mouthWide': 0.2 
            },
            'ae': { 
                'mouthWide': 0.8, 
                'mouthOpen': 0.4, 
                'jawOpen': 0.3 
            },
            'ah': { 
                'mouthOpen': 0.9, 
                'jawOpen': 0.8 
            },
            'ao': { 
                'mouthFunnel': 0.85, 
                'mouthPucker': 0.7, 
                'mouthOpen': 0.3 
            },
            'aw': { 
                'mouthOpen': 0.8, 
                'jawOpen': 0.7, 
                'mouthWide': 0.5 
            },
            'ay': { 
                'mouthSmileLeft': 0.6, 
                'mouthSmileRight': 0.6, 
                'mouthWide': 0.3 
            },
            'b_m_p': { 
                'mouthClose': 0.95, 
                'mouthPress': 0.8 
            },
            'ch_j_sh_zh': { 
                'mouthFunnel': 0.7, 
                'mouthPucker': 0.6, 
                'mouthOpen': 0.2 
            },
            'd_s_t': { 
                'tongueUp': 0.9, 
                'mouthOpen': 0.35, 
                'jawOpen': 0.2 
            },
            'eh': { 
                'mouthOpen': 0.5, 
                'jawOpen': 0.3, 
                'mouthWide': 0.4 
            },
            'er': { 
                'tongueCurl': 0.85, 
                'mouthFunnel': 0.4, 
                'mouthOpen': 0.3 
            },
            'f_v': { 
                'mouthLowerDown': 0.7, 
                'mouthUpperUp': 0.3 
            },
            'g_k': { 
                'tongueBack': 0.8, 
                'mouthOpen': 0.4, 
                'jawOpen': 0.2 
            },
            'hh': { 
                'mouthOpen': 0.6, 
                'jawOpen': 0.4 
            },
            'ih': { 
                'mouthOpen': 0.3, 
                'mouthWide': 0.3, 
                'jawOpen': 0.15 
            },
            'iy': { 
                'mouthSmileLeft': 0.8, 
                'mouthSmileRight': 0.8, 
                'mouthWide': 0.4 
            },
            'l': { 
                'tongueUp': 0.95, 
                'mouthOpen': 0.4, 
                'jawOpen': 0.25 
            },
            'n': { 
                'tongueUp': 0.9, 
                'mouthClose': 0.3, 
                'mouthOpen': 0.2 
            },
            'ng': { 
                'tongueBack': 0.9, 
                'mouthClose': 0.5 
            },
            'ow': { 
                'mouthFunnel': 0.9, 
                'mouthPucker': 0.8, 
                'mouthOpen': 0.4 
            },
            'oy': { 
                'mouthFunnel': 0.6, 
                'mouthPucker': 0.5, 
                'mouthSmileLeft': 0.4, 
                'mouthSmileRight': 0.4 
            },
            'r': { 
                'tongueCurl': 0.95, 
                'mouthFunnel': 0.5, 
                'mouthOpen': 0.3, 
                'mouthPucker': 0.3 
            },
            'th': { 
                'tongueOut': 0.9, 
                'mouthOpen': 0.5, 
                'jawOpen': 0.3 
            },
            'uh': { 
                'mouthPucker': 0.7, 
                'mouthOpen': 0.3, 
                'mouthFunnel': 0.4 
            },
            'uw': { 
                'mouthPucker': 0.95, 
                'mouthFunnel': 0.8, 
                'mouthOpen': 0.3 
            },
            'w': { 
                'mouthPucker': 0.85, 
                'mouthFunnel': 0.7 
            },
            'y': { 
                'mouthSmileLeft': 0.5, 
                'mouthSmileRight': 0.5, 
                'mouthWide': 0.2 
            },
            'z': { 
                'mouthOpen': 0.25, 
                'mouthWide': 0.4, 
                'mouthUpperUp': 0.2 
            }
        };

        const UNITY_VISEME_DESCRIPTIONS = {
            'sil': 'Silence/Neutral',
            'aa': 'Father - wide open',
            'ae': 'Cat - stretched',
            'ah': 'Hot - very open',
            'ao': 'Thought - rounded',
            'aw': 'Loud - wide open',
            'ay': 'Hide - smile',
            'b_m_p': 'Lips together',
            'ch_j_sh_zh': 'Church - rounded',
            'd_s_t': 'Tongue to teeth',
            'eh': 'Pet - mid-open',
            'er': 'Bird - R sound',
            'f_v': 'Teeth on lip',
            'g_k': 'Back tongue',
            'hh': 'Breathy H',
            'ih': 'Bit - small',
            'iy': 'Beat - smile',
            'l': 'Tongue up L',
            'n': 'Tongue up N',
            'ng': 'Back tongue NG',
            'ow': 'Boat - round',
            'oy': 'Boy - round smile',
            'r': 'Red - tongue curl',
            'th': 'Tongue out',
            'uh': 'Put - small round',
            'uw': 'Boot - tight round',
            'w': 'Way - protrusion',
            'y': 'Yes - slight smile',
            'z': 'Zoo - teeth'
        };

        function initUnityComponents() {
            createUnityVisemeControls();
            updateUnityStatus('Ready! Initialize Unity Bridge to begin', '#28a745');
        }

        function createUnityVisemeControls() {
            const container = document.getElementById('unity-viseme-controls');
            Object.entries(UNITY_MORPH_MAPPINGS).forEach(([viseme, morphs]) => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.textContent = `${viseme.toUpperCase()} - ${UNITY_VISEME_DESCRIPTIONS[viseme]}`;
                btn.onclick = () => setUnityViseme(viseme, btn);
                container.appendChild(btn);
            });
        }

        function updateUnityStatus(message, color = '#333') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.background = color;
        }

        function updateBridgeStatus(message, isConnected = false) {
            const bridgeStatus = document.getElementById('bridge-status');
            bridgeStatus.textContent = message;
            bridgeStatus.style.color = isConnected ? '#4CAF50' : '#aaa';
        }

        function initUnityBridge() {
            updateUnityStatus('🔗 Initializing Unity WebGL Bridge...', '#ff9800');
            updateBridgeStatus('Connecting to Unity instance...', false);

            // Simulate Unity bridge initialization
            setTimeout(() => {
                unityBridgeInitialized = true;
                
                // Simulate Unity bridge global methods
                window.UnityWebGLMorphFix = {
                    setViseme: (viseme, intensity) => {
                        console.log(`Unity Bridge: Setting viseme ${viseme} with intensity ${intensity}`);
                        return { success: true, morphsApplied: Object.keys(UNITY_MORPH_MAPPINGS[viseme] || {}).length };
                    },
                    
                    applyMorphs: (morphs) => {
                        console.log('Unity Bridge: Applying morphs', morphs);
                        Object.entries(morphs).forEach(([morph, value]) => {
                            simulatedUnityMorphs[morph] = value;
                        });
                        return { success: true, morphsApplied: Object.keys(morphs).length };
                    },
                    
                    resetMorphs: () => {
                        console.log('Unity Bridge: Resetting all morphs');
                        simulatedUnityMorphs = {};
                        return { success: true };
                    },
                    
                    getMorphs: () => {
                        return simulatedUnityMorphs;
                    }
                };

                updateUnityStatus('✅ Unity Bridge initialized successfully!', '#28a745');
                updateBridgeStatus('Bridge active - Unity communication ready', true);
                
            }, 1500);
        }

        function loadUnityAvatar() {
            if (!unityBridgeInitialized) {
                updateUnityStatus('❌ Initialize Unity Bridge first', '#dc3545');
                return;
            }

            updateUnityStatus('👤 Loading Unity Avatar...', '#ff9800');

            // Simulate Unity avatar loading
            setTimeout(() => {
                unityAvatarLoaded = true;
                
                // Simulate available Unity BlendShapes
                const unityBlendShapes = [
                    'mouthOpen', 'jawOpen', 'mouthClose', 'mouthWide', 'mouthSmileLeft', 'mouthSmileRight',
                    'mouthFunnel', 'mouthPucker', 'mouthPress', 'mouthLowerDown', 'mouthUpperUp',
                    'tongueUp', 'tongueOut', 'tongueCurl', 'tongueBack',
                    'cheekPuff', 'noseSneer'
                ];

                updateUnityStatus('✅ Unity Avatar loaded with BlendShapes!', '#28a745');
                displayUnityMorphsInfo(unityBlendShapes);
                
            }, 1200);
        }

        function displayUnityMorphsInfo(blendShapes) {
            const container = document.getElementById('unity-morphs-info');
            
            let html = `<strong>Unity BlendShapes: ${blendShapes.length}</strong><br><br>`;
            html += `<div style="font-size: 11px; color: #888;">Available BlendShapes:</div>`;
            
            blendShapes.forEach(shape => {
                html += `<div class="morph-mapping">• ${shape}</div>`;
            });

            container.innerHTML = html;
        }

        function setUnityViseme(viseme, button) {
            if (!unityBridgeInitialized || !unityAvatarLoaded) {
                updateUnityStatus('❌ Initialize bridge and load avatar first', '#dc3545');
                return;
            }

            // Clear active states
            document.querySelectorAll('#unity-viseme-controls .btn').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            // Reset morphs first
            if (window.UnityWebGLMorphFix) {
                window.UnityWebGLMorphFix.resetMorphs();
            }

            // Apply Unity morphs for this viseme
            const morphsToApply = UNITY_MORPH_MAPPINGS[viseme] || {};
            let appliedCount = 0;

            // Scale morphs by intensity
            const scaledMorphs = {};
            Object.entries(morphsToApply).forEach(([morphName, baseValue]) => {
                scaledMorphs[morphName] = baseValue * unityCurrentIntensity;
                appliedCount++;
            });

            // Apply through Unity bridge
            if (window.UnityWebGLMorphFix && Object.keys(scaledMorphs).length > 0) {
                const result = window.UnityWebGLMorphFix.applyMorphs(scaledMorphs);
                console.log(`Unity result:`, result);
                
                // Log applied morphs for verification
                Object.entries(scaledMorphs).forEach(([morphName, value]) => {
                    if (value > 0.1) {
                        console.log(`Applied Unity BlendShape ${morphName}: ${value.toFixed(3)}`);
                    }
                });
            }

            updateUnityStatus(`🎭 ${viseme.toUpperCase()}: ${appliedCount} Unity BlendShapes applied`, '#17a2b8');
            updateBridgeStatus(`Last command: setViseme(${viseme}, ${unityCurrentIntensity})`, true);
        }

        function updateUnityIntensity(value) {
            unityCurrentIntensity = parseFloat(value);
            document.getElementById('unity-intensity-value').textContent = value;

            // Re-apply current viseme if any is active
            const activeBtn = document.querySelector('#unity-viseme-controls .btn.active');
            if (activeBtn) {
                const viseme = activeBtn.textContent.split(' ')[0].toLowerCase();
                setUnityViseme(viseme, activeBtn);
            }
        }

        async function runUnityAutoTest() {
            if (!unityBridgeInitialized || !unityAvatarLoaded) {
                updateUnityStatus('❌ Initialize bridge and load avatar first', '#dc3545');
                return;
            }

            updateUnityStatus('🚀 Running Unity auto test...', '#ff9800');

            const visemes = Object.keys(UNITY_MORPH_MAPPINGS);
            const buttons = document.querySelectorAll('#unity-viseme-controls .btn');

            for (let i = 0; i < visemes.length; i++) {
                const viseme = visemes[i];
                const button = buttons[i];

                updateUnityStatus(`Testing ${i + 1}/${visemes.length}: ${viseme.toUpperCase()}`, '#17a2b8');
                setUnityViseme(viseme, button);

                await new Promise(resolve => setTimeout(resolve, 600));
            }

            updateUnityStatus('✅ Unity auto test completed!', '#28a745');
            updateBridgeStatus('Auto test complete - Bridge ready for manual testing', true);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initUnityComponents();
        });
    </script>
</body>
</html>