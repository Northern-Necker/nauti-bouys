<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Three.js Morph Test</title>
</head>
<body>
    <h1>üé≠ Local Three.js Morph Test - Using Installed Package</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">üîç Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">üîç Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">üì∑ Reset</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">üë§ Head Focus</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 350px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa;">
                <h3>Avatar Controls</h3>
                
                <div style="margin: 15px 0;">
                    <h4>üîÑ Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0; font-weight: bold;">üöÄ LOAD AVATAR</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üé≠ Test Visemes (Max Intensity)</h4>
                    <button onclick="testViseme('aa')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #ffc107; font-weight: bold;">AA - MOUTH WIDE OPEN</button>
                    <button onclick="testViseme('uw')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #17a2b8; color: white; font-weight: bold;">UW - LIPS ROUND</button>
                    <button onclick="testViseme('th')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #dc3545; color: white; font-weight: bold;">TH - TONGUE OUT</button>
                    <button onclick="testViseme('iy')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #28a745; color: white; font-weight: bold;">IY - BIG SMILE</button>
                    <button onclick="testViseme('sil')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #6c757d; color: white; font-weight: bold;">SIL - RESET NEUTRAL</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <button onclick="runQuickTest()" style="width: 100%; padding: 12px; background: #e83e8c; color: white; border: none; border-radius: 4px; font-weight: bold;">‚ö° QUICK TEST ALL</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìä Status</h4>
                    <div id="status" style="padding: 12px; background: #e9ecef; border-radius: 4px; font-size: 13px; font-weight: bold;">Loading Three.js modules...</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìã Morph Details</h4>
                    <div id="morphs" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 11px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd;">Waiting for avatar...</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, avatar, morphTargets = [], controls;
        let currentIntensity = 1.0; // Max intensity for maximum visibility

        console.log('Starting local Three.js morph test...');

        function updateStatus(msg, color = '#e9ecef') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = msg;
            statusEl.style.background = color;
            console.log('STATUS:', msg);
        }

        function updateMorphs(msg) {
            document.getElementById('morphs').innerHTML = msg;
        }

        // Import Three.js modules from local installation
        updateStatus('Loading Three.js modules from local installation...', '#ffc107');

        try {
            const THREE = await import('/node_modules/three/build/three.module.js');
            const { GLTFLoader } = await import('/node_modules/three/examples/jsm/loaders/GLTFLoader.js');
            const { OrbitControls } = await import('/node_modules/three/examples/jsm/controls/OrbitControls.js');
            
            console.log('‚úÖ Three.js modules loaded successfully!', THREE);
            updateStatus('‚úÖ Three.js loaded! Initializing scene...', '#28a745');

            // Initialize scene immediately after loading
            initializeScene(THREE, GLTFLoader, OrbitControls);

        } catch (error) {
            console.error('‚ùå Failed to load Three.js modules:', error);
            updateStatus('‚ùå Failed to load Three.js: ' + error.message, '#f8d7da');
            
            // Try alternative import paths
            tryAlternativeImports();
        }

        async function tryAlternativeImports() {
            updateStatus('Trying alternative import paths...', '#ffc107');
            
            try {
                // Try direct imports without /node_modules path
                const THREE = await import('three');
                const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
                const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
                
                console.log('‚úÖ Alternative imports successful!');
                updateStatus('‚úÖ Three.js loaded via alternative path!', '#28a745');
                initializeScene(THREE, GLTFLoader, OrbitControls);
                
            } catch (altError) {
                console.error('‚ùå Alternative imports also failed:', altError);
                updateStatus('‚ùå All import methods failed. Check Three.js installation.', '#f8d7da');
                
                // Show detailed error info
                updateMorphs(`
                    <strong>‚ùå Three.js Loading Failed</strong><br><br>
                    <strong>Error:</strong> ${altError.message}<br><br>
                    <strong>Possible Solutions:</strong><br>
                    1. Check if Three.js is properly installed<br>
                    2. Try refreshing the page<br>
                    3. Check browser console for more details<br><br>
                    <strong>Current Status:</strong><br>
                    - Three.js package version: 0.179.1<br>
                    - Import method: ES6 modules<br>
                    - Dev server: Vite
                `);
            }
        }

        function initializeScene(THREE, GLTFLoader, OrbitControls) {
            console.log('Initializing Three.js scene...');
            
            // Make modules globally available
            window.THREE = THREE;
            window.GLTFLoader = GLTFLoader;
            window.OrbitControls = OrbitControls;

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x404040);

            // Create camera
            camera = new THREE.PerspectiveCamera(50, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = true;

            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.6, 0);

            // Professional lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
            keyLight.position.set(2, 3, 4);
            keyLight.castShadow = true;
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-2, 1, 2);
            scene.add(fillLight);

            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(0, 1, -3);
            scene.add(rimLight);

            // Start render loop
            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('‚úÖ Scene ready! Click LOAD AVATAR to begin testing', '#d4edda');
            console.log('‚úÖ Scene initialization complete');
        }

        window.loadAvatar = function() {
            if (!window.GLTFLoader || !scene) {
                updateStatus('‚ùå Three.js not properly initialized!', '#f8d7da');
                return;
            }

            updateStatus('üîÑ Loading SavannahAvatar.glb...', '#ffc107');
            console.log('Starting avatar load...');

            const loader = new window.GLTFLoader();

            // GLB file paths to try
            const glbPaths = [
                './assets/SavannahAvatar.glb',
                './dist/assets/SavannahAvatar.glb',
                './public/assets/SavannahAvatar.glb'
            ];

            let pathIndex = 0;

            function tryNextPath() {
                if (pathIndex >= glbPaths.length) {
                    updateStatus('‚ùå No GLB file found at any expected path', '#f8d7da');
                    updateMorphs(`
                        <strong>‚ùå GLB File Not Found</strong><br><br>
                        <strong>Tried paths:</strong><br>
                        ${glbPaths.map(path => `‚Ä¢ ${path}`).join('<br>')}<br><br>
                        <strong>Make sure SavannahAvatar.glb is in one of these locations.</strong>
                    `);
                    return;
                }

                const currentPath = glbPaths[pathIndex];
                updateStatus(`üì• Trying: ${currentPath}`, '#17a2b8');
                console.log(`Trying to load: ${currentPath}`);

                loader.load(
                    currentPath,
                    (gltf) => {
                        console.log('‚úÖ GLB loaded successfully!', gltf);
                        updateStatus('‚úÖ GLB loaded! Setting up avatar...', '#28a745');
                        setupAvatar(gltf);
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateStatus(`üì• Loading GLB... ${percent}%`, '#17a2b8');
                    },
                    (error) => {
                        console.warn(`Failed to load ${currentPath}:`, error);
                        pathIndex++;
                        setTimeout(tryNextPath, 300);
                    }
                );
            }

            tryNextPath();
        };

        function setupAvatar(gltf) {
            console.log('Setting up avatar...');

            // Remove existing avatar
            if (avatar) {
                scene.remove(avatar);
            }

            avatar = gltf.scene;
            scene.add(avatar);

            // Calculate bounding box for intelligent scaling
            const box = new window.THREE.Box3().setFromObject(avatar);
            const size = box.getSize(new window.THREE.Vector3());
            const center = box.getCenter(new window.THREE.Vector3());

            console.log('Avatar original size:', size);

            // Apply AGGRESSIVE scaling for maximum visibility
            let scale = 3.0; // Start with 3x scale
            if (size.y < 1.0) {
                scale = 3.0 / size.y; // Scale to 3 units tall for huge visibility
            }
            
            avatar.scale.setScalar(scale);
            avatar.position.copy(center).multiplyScalar(-1);
            avatar.position.y = 0;

            console.log(`Applied ${scale.toFixed(2)}x scaling`);

            // Position camera for optimal face viewing
            const headY = size.y * scale * 0.8;
            camera.position.set(0, headY, 2.5);
            controls.target.set(0, headY, 0);
            controls.update();

            // Find and catalog ALL morph targets
            morphTargets = [];
            let meshAnalysis = {};

            avatar.traverse((child) => {
                if (child.isMesh && child.morphTargetDictionary) {
                    console.log(`Found morph mesh: ${child.name}`, child.morphTargetDictionary);

                    const morphCount = Object.keys(child.morphTargetDictionary).length;
                    if (!child.morphTargetInfluences || child.morphTargetInfluences.length !== morphCount) {
                        child.morphTargetInfluences = new Array(morphCount).fill(0);
                    }

                    const meshMorphs = [];
                    Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                        morphTargets.push({
                            name: name,
                            mesh: child,
                            meshName: child.name,
                            index: index
                        });
                        meshMorphs.push(name);
                    });

                    meshAnalysis[child.name] = meshMorphs;
                }
            });

            updateStatus(`üéâ AVATAR READY! ${morphTargets.length} morphs found - TEST VISEMES NOW!`, '#d4edda');
            console.log(`‚úÖ Avatar setup complete! Found ${morphTargets.length} morphs`);

            // Display comprehensive morph analysis
            displayMorphAnalysis(meshAnalysis);
        }

        function displayMorphAnalysis(meshAnalysis) {
            let html = `<strong>üéâ AVATAR LOADED SUCCESSFULLY!</strong><br><br>`;
            html += `<strong>Total Morph Targets: ${morphTargets.length}</strong><br><br>`;

            if (morphTargets.length > 0) {
                html += '<strong>Morph Breakdown by Mesh:</strong><br><br>';
                
                Object.entries(meshAnalysis).forEach(([meshName, morphs]) => {
                    html += `<strong>${meshName}</strong> (${morphs.length}):<br>`;
                    
                    // Show first few morphs
                    morphs.slice(0, 8).forEach(morph => {
                        html += `&nbsp;&nbsp;‚Ä¢ ${morph}<br>`;
                    });
                    
                    if (morphs.length > 8) {
                        html += `&nbsp;&nbsp;... +${morphs.length - 8} more<br>`;
                    }
                    html += '<br>';
                });
                
                html += '<strong>üé≠ READY FOR VISEME TESTING!</strong><br>';
                html += 'Click the viseme buttons above to test facial expressions.';
                
            } else {
                html += '‚ùå No morph targets found in this GLB model.';
            }

            updateMorphs(html);
        }

        window.testViseme = function(viseme) {
            if (!avatar || morphTargets.length === 0) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            console.log(`Testing viseme: ${viseme}`);
            updateStatus(`üé≠ Testing ${viseme.toUpperCase()} at MAX INTENSITY`, '#17a2b8');

            // Reset all morphs to zero first
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });

            if (viseme === 'sil') {
                updateStatus('‚úÖ RESET TO NEUTRAL (SIL)', '#d4edda');
                console.log('Reset all morphs to neutral');
                return;
            }

            // Enhanced search mappings with more search terms
            const morphSearchMappings = {
                'aa': ['mouth_open', 'mouthopen', 'open', 'jaw_open', 'jawopen', 'wide', 'ah', 'father'],
                'uw': ['mouth_pucker', 'mouthpucker', 'pucker', 'mouth_funnel', 'mouthfunnel', 'funnel', 'round', 'oo', 'boot'],
                'th': ['tongue_out', 'tongueout', 'tongue', 'tip', 'th'],
                'iy': ['mouth_smile', 'mouthsmile', 'smile', 'grin', 'corners', 'beat'],
                'ow': ['mouth_funnel', 'mouthfunnel', 'funnel', 'round', 'boat', 'ow']
            };

            const searchTerms = morphSearchMappings[viseme] || [viseme];
            let appliedMorphs = [];

            // Search for matching morphs with multiple strategies
            searchTerms.forEach(searchTerm => {
                morphTargets.forEach(morph => {
                    const morphName = morph.name.toLowerCase();
                    const term = searchTerm.toLowerCase();
                    
                    // Multiple matching strategies
                    if (morphName.includes(term) || 
                        term.includes(morphName) ||
                        morphName.replace(/_/g, '').includes(term.replace(/_/g, '')) ||
                        morphName.replace(/[_\s]/g, '').includes(term.replace(/[_\s]/g, ''))) {
                        
                        // Apply MAXIMUM intensity for visibility
                        const intensity = 1.0;
                        morph.mesh.morphTargetInfluences[morph.index] = intensity;
                        
                        // Force geometry updates
                        if (morph.mesh.geometry.morphAttributes) {
                            morph.mesh.geometry.morphAttributesNeedUpdate = true;
                        }
                        morph.mesh.updateMatrix();
                        morph.mesh.updateMatrixWorld(true);
                        
                        appliedMorphs.push({
                            name: morph.name,
                            value: intensity,
                            mesh: morph.meshName
                        });
                        
                        console.log(`‚úÖ Applied morph: ${morph.name} = ${intensity} (${morph.meshName})`);
                    }
                });
            });

            // Update status and display results
            if (appliedMorphs.length > 0) {
                updateStatus(`üéâ ${viseme.toUpperCase()}: ${appliedMorphs.length} morphs applied at MAX intensity!`, '#d4edda');
                
                let morphHtml = `<strong>‚úÖ Applied for ${viseme.toUpperCase()}:</strong><br><br>`;
                appliedMorphs.forEach(morph => {
                    morphHtml += `üéØ <strong>${morph.name}</strong>: ${morph.value.toFixed(2)} (${morph.mesh})<br>`;
                });
                
                morphHtml += `<br><strong>Total: ${appliedMorphs.length} morphs activated</strong>`;
                updateMorphs(morphHtml);
                
            } else {
                updateStatus(`‚ö†Ô∏è NO MORPHS FOUND for ${viseme.toUpperCase()}`, '#fff3cd');
                
                let searchHtml = `<strong>‚ùå No matches for ${viseme.toUpperCase()}</strong><br><br>`;
                searchHtml += `<strong>Searched for:</strong> ${searchTerms.join(', ')}<br><br>`;
                searchHtml += '<strong>Available morphs:</strong><br>';
                morphTargets.slice(0, 20).forEach(morph => {
                    searchHtml += `‚Ä¢ ${morph.name} (${morph.meshName})<br>`;
                });
                if (morphTargets.length > 20) {
                    searchHtml += `<br>... and ${morphTargets.length - 20} more morphs`;
                }
                updateMorphs(searchHtml);
            }
        };

        window.runQuickTest = async function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('‚ö° Running quick viseme test sequence...', '#ffc107');
            const visemes = ['aa', 'uw', 'th', 'iy', 'sil'];
            
            for (let i = 0; i < visemes.length; i++) {
                const viseme = visemes[i];
                updateStatus(`‚ö° Quick test ${i + 1}/${visemes.length}: ${viseme.toUpperCase()}`, '#17a2b8');
                testViseme(viseme);
                await new Promise(resolve => setTimeout(resolve, 2000)); // 2 second pause to see changes
            }
            
            updateStatus('‚úÖ Quick test completed! Check for facial changes', '#d4edda');
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.3));
                if (controls) controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.3));
                if (controls) controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 3);
                controls.target.set(0, 1.6, 0);
                controls.update();
                updateStatus('üì∑ Camera reset to default position');
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                const box = new window.THREE.Box3().setFromObject(avatar);
                const size = box.getSize(new window.THREE.Vector3());
                const headY = size.y * 0.9; // Focus very high on head
                camera.position.set(0, headY, 1.8);
                controls.target.set(0, headY, 0);
                controls.update();
                updateStatus('üì∑ Camera focused on head/face area');
            }
        };

    </script>
</body>
</html>