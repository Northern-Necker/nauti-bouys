<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transparency Fix - GLB Morph Test</title>
</head>
<body>
    <h1>🎭 Transparency Fix - All Meshes Now Visible!</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">🔍 Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">🔍 Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">📷 Reset</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">👤 Head Focus</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 350px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa;">
                <h3>FIXED Avatar Controls</h3>
                
                <div style="margin: 15px 0;">
                    <h4>🔄 Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0; font-weight: bold;">🚀 LOAD AVATAR (FIXED)</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>🎭 Test Visemes - Face Now Visible!</h4>
                    <button onclick="testViseme('aa')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #ffc107; font-weight: bold;">AA - MOUTH WIDE OPEN</button>
                    <button onclick="testViseme('uw')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #17a2b8; color: white; font-weight: bold;">UW - LIPS PUCKER</button>
                    <button onclick="testViseme('th')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #dc3545; color: white; font-weight: bold;">TH - TONGUE OUT</button>
                    <button onclick="testViseme('iy')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #28a745; color: white; font-weight: bold;">IY - BIG SMILE</button>
                    <button onclick="testViseme('ow')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #6f42c1; color: white; font-weight: bold;">OW - ROUND MOUTH</button>
                    <button onclick="testViseme('sil')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #6c757d; color: white; font-weight: bold;">SIL - RESET NEUTRAL</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <button onclick="runFullTest()" style="width: 100%; padding: 12px; background: #e83e8c; color: white; border: none; border-radius: 4px; font-weight: bold;">⚡ FULL VISEME TEST</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>🎚️ Morph Intensity</h4>
                    <input type="range" id="intensity" min="0" max="1" step="0.1" value="1.0" style="width: 100%;" oninput="updateIntensity(this.value)">
                    <div>Intensity: <span id="intensity-value">1.0</span> (Maximum for visibility)</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>📊 Status</h4>
                    <div id="status" style="padding: 12px; background: #e9ecef; border-radius: 4px; font-size: 12px; font-weight: bold;">Loading...</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>🎭 Morph Results</h4>
                    <div id="morphs" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 11px; max-height: 250px; overflow-y: auto; border: 1px solid #ddd;">Waiting for avatar...</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, avatar, morphTargets = [], controls;
        let currentIntensity = 1.0;

        function updateStatus(msg, color = '#e9ecef') {
            document.getElementById('status').textContent = msg;
            document.getElementById('status').style.background = color;
            console.log('STATUS:', msg);
        }

        function updateMorphs(msg) {
            document.getElementById('morphs').innerHTML = msg;
        }

        updateStatus('Loading Three.js with transparency fixes...', '#ffc107');

        try {
            const THREE = await import('three');
            const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
            
            window.THREE = THREE;
            window.GLTFLoader = GLTFLoader;
            window.OrbitControls = OrbitControls;

            initializeScene();

        } catch (error) {
            updateStatus('❌ Failed to load Three.js: ' + error.message, '#f8d7da');
        }

        function initializeScene() {
            console.log('🎭 Initializing scene with transparency fixes...');
            
            scene = new window.THREE.Scene();
            scene.background = new window.THREE.Color(0x404040);

            camera = new window.THREE.PerspectiveCamera(50, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Renderer optimized for transparent materials
            renderer = new window.THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true,
                alpha: false,
                premultipliedAlpha: false
            });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = window.THREE.PCFSoftShadowMap;
            
            // Critical settings for transparency issues
            renderer.outputColorSpace = window.THREE.SRGBColorSpace;
            renderer.sortObjects = true;
            
            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            controls = new window.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.6, 0);

            // Good lighting for face visibility
            const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const keyLight = new window.THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(2, 3, 4);
            keyLight.castShadow = true;
            scene.add(keyLight);

            const fillLight = new window.THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-2, 1, 2);
            scene.add(fillLight);

            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('✅ Scene ready! Load avatar to see ALL meshes', '#d4edda');
        }

        window.loadAvatar = function() {
            updateStatus('🔄 Loading avatar with TRANSPARENCY FIXES...', '#ffc107');
            
            const loader = new window.GLTFLoader();
            const glbPaths = [
                './assets/SavannahAvatar.glb',
                './dist/assets/SavannahAvatar.glb', 
                './public/assets/SavannahAvatar.glb'
            ];

            let pathIndex = 0;

            function tryLoad() {
                if (pathIndex >= glbPaths.length) {
                    updateStatus('❌ No GLB found', '#f8d7da');
                    return;
                }

                const path = glbPaths[pathIndex];
                updateStatus(`📥 Loading: ${path}`, '#17a2b8');

                loader.load(
                    path,
                    (gltf) => {
                        updateStatus('✅ GLB loaded! Fixing transparency...', '#28a745');
                        setupFixedAvatar(gltf);
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateStatus(`Loading... ${percent}%`, '#17a2b8');
                    },
                    (error) => {
                        pathIndex++;
                        setTimeout(tryLoad, 300);
                    }
                );
            }

            tryLoad();
        };

        function setupFixedAvatar(gltf) {
            console.log('🔧 Setting up avatar with CRITICAL transparency fixes...');

            if (avatar) scene.remove(avatar);

            avatar = gltf.scene;

            // CRITICAL: Fix the transparency issue that's making meshes invisible
            fixTransparencyIssues(avatar);

            scene.add(avatar);

            // Scaling and positioning
            const box = new window.THREE.Box3().setFromObject(avatar);
            const size = box.getSize(new window.THREE.Vector3());

            let scale = 2.5;
            if (size.y < 1.0) scale = 2.5 / size.y;
            
            avatar.scale.setScalar(scale);
            avatar.position.y = 0;

            // Position camera for optimal face viewing
            const headY = size.y * scale * 0.85;
            camera.position.set(0, headY, 2.5);
            controls.target.set(0, headY, 0);
            controls.update();

            updateStatus('🎉 AVATAR READY! Face should now be VISIBLE!', '#d4edda');
            displayMorphAnalysis();
        }

        function fixTransparencyIssues(avatarScene) {
            console.log('🔧 FIXING CRITICAL TRANSPARENCY ISSUES...');
            
            morphTargets = [];
            let fixedCount = 0;
            let meshCount = 0;

            avatarScene.traverse((child) => {
                if (child.isMesh) {
                    meshCount++;
                    console.log(`Fixing transparency in: ${child.name}`);

                    // CRITICAL VISIBILITY FIXES
                    child.visible = true;
                    child.frustumCulled = false;
                    child.castShadow = true;
                    child.receiveShadow = true;

                    if (child.material) {
                        // **THIS IS THE KEY FIX** - Force transparency OFF
                        child.material.transparent = false;  // ← CRITICAL!
                        child.material.opacity = 1.0;
                        child.material.alphaTest = 0;
                        child.material.depthTest = true;
                        child.material.depthWrite = true;
                        
                        // Handle side rendering based on mesh type
                        if (child.name.toLowerCase().includes('hair')) {
                            child.material.side = window.THREE.DoubleSide;
                            child.material.alphaTest = 0.1; // Allow some alpha for hair
                        } else {
                            child.material.side = window.THREE.FrontSide;
                        }

                        // Force material update
                        child.material.needsUpdate = true;
                        fixedCount++;

                        console.log(`✅ Fixed ${child.name}:`, {
                            transparent: child.material.transparent,
                            opacity: child.material.opacity,
                            alphaTest: child.material.alphaTest,
                            side: child.material.side
                        });
                    }

                    // Handle geometry
                    if (child.geometry) {
                        child.geometry.computeBoundingBox();
                        child.geometry.computeBoundingSphere();
                        child.geometry.computeVertexNormals();
                    }

                    // Handle morphs - this is where our 105 morph targets are!
                    if (child.morphTargetDictionary) {
                        console.log(`Found morphs in: ${child.name}`, Object.keys(child.morphTargetDictionary));

                        const morphCount = Object.keys(child.morphTargetDictionary).length;
                        if (!child.morphTargetInfluences) {
                            child.morphTargetInfluences = new Array(morphCount).fill(0);
                        }

                        Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                            morphTargets.push({
                                name: name,
                                mesh: child,
                                meshName: child.name,
                                index: index
                            });
                        });
                    }
                }
            });

            console.log(`🔧 FIXED ${fixedCount} materials in ${meshCount} meshes`);
            console.log(`🎭 Found ${morphTargets.length} morph targets for facial animation`);
        }

        function displayMorphAnalysis() {
            let html = `<strong>🎉 AVATAR LOADED WITH FIXES!</strong><br><br>`;
            html += `<strong>✅ All meshes now visible</strong><br>`;
            html += `<strong>🎭 Morph Targets: ${morphTargets.length}</strong><br><br>`;

            if (morphTargets.length > 0) {
                // Group morphs by mesh
                const morphsByMesh = {};
                morphTargets.forEach(morph => {
                    if (!morphsByMesh[morph.meshName]) {
                        morphsByMesh[morph.meshName] = [];
                    }
                    morphsByMesh[morph.meshName].push(morph.name);
                });

                html += '<strong>🎭 Morphs by Mesh:</strong><br><br>';
                Object.entries(morphsByMesh).forEach(([meshName, morphs]) => {
                    html += `<strong>${meshName}</strong> (${morphs.length}):<br>`;
                    
                    // Show sample morphs
                    morphs.slice(0, 6).forEach(morph => {
                        html += `&nbsp;&nbsp;• ${morph}<br>`;
                    });
                    
                    if (morphs.length > 6) {
                        html += `&nbsp;&nbsp;... +${morphs.length - 6} more<br>`;
                    }
                    html += '<br>';
                });
                
                html += '<strong>🎭 READY FOR VISEME TESTING!</strong><br>';
                html += 'The face is now visible - test the visemes above!';
                
            } else {
                html += '❌ No morph targets found.';
            }

            updateMorphs(html);
        }

        window.testViseme = function(viseme) {
            if (!avatar || morphTargets.length === 0) {
                updateStatus('❌ Load avatar first!', '#f8d7da');
                return;
            }

            console.log(`🎭 Testing viseme: ${viseme}`);
            updateStatus(`🎭 Testing ${viseme.toUpperCase()} at intensity ${currentIntensity}`, '#17a2b8');

            // Reset all morphs first
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });

            if (viseme === 'sil') {
                updateStatus('✅ RESET TO NEUTRAL (SIL)', '#d4edda');
                console.log('Reset all morphs to neutral');
                return;
            }

            // Enhanced morph search mappings
            const morphSearchMappings = {
                'aa': ['mouth_open', 'mouthopen', 'open', 'jaw_open', 'jawopen', 'wide', 'ah'],
                'uw': ['mouth_pucker', 'mouthpucker', 'pucker', 'mouth_funnel', 'mouthfunnel', 'funnel', 'round', 'oo'],
                'th': ['tongue_out', 'tongueout', 'tongue', 'tip', 'th'],
                'iy': ['mouth_smile', 'mouthsmile', 'smile', 'grin', 'corners', 'beat'],
                'ow': ['mouth_funnel', 'mouthfunnel', 'funnel', 'round', 'boat', 'ow']
            };

            const searchTerms = morphSearchMappings[viseme] || [viseme];
            let appliedMorphs = [];

            // Search for matching morphs
            searchTerms.forEach(searchTerm => {
                morphTargets.forEach(morph => {
                    const morphName = morph.name.toLowerCase();
                    const term = searchTerm.toLowerCase();
                    
                    if (morphName.includes(term) || 
                        term.includes(morphName) ||
                        morphName.replace(/[_\s]/g, '').includes(term.replace(/[_\s]/g, ''))) {
                        
                        // Apply morph at current intensity
                        const intensity = currentIntensity;
                        morph.mesh.morphTargetInfluences[morph.index] = intensity;
                        
                        // Force geometry updates for immediate visual feedback
                        if (morph.mesh.geometry.morphAttributes) {
                            morph.mesh.geometry.morphAttributesNeedUpdate = true;
                        }
                        morph.mesh.updateMatrix();
                        morph.mesh.updateMatrixWorld(true);
                        
                        appliedMorphs.push({
                            name: morph.name,
                            value: intensity,
                            mesh: morph.meshName
                        });
                        
                        console.log(`✅ Applied: ${morph.name} = ${intensity} (${morph.meshName})`);
                    }
                });
            });

            // Update status and display results
            if (appliedMorphs.length > 0) {
                updateStatus(`🎉 ${viseme.toUpperCase()}: ${appliedMorphs.length} morphs applied!`, '#d4edda');
                
                let morphHtml = `<strong>✅ Applied for ${viseme.toUpperCase()}:</strong><br><br>`;
                appliedMorphs.forEach(morph => {
                    morphHtml += `🎯 <strong>${morph.name}</strong>: ${morph.value.toFixed(2)} (${morph.mesh})<br>`;
                });
                
                morphHtml += `<br><strong>Total: ${appliedMorphs.length} morphs activated</strong><br>`;
                morphHtml += '<strong>You should see facial movement now! 🎭</strong>';
                updateMorphs(morphHtml);
                
            } else {
                updateStatus(`⚠️ NO MORPHS FOUND for ${viseme.toUpperCase()}`, '#fff3cd');
                
                let searchHtml = `<strong>❌ No matches for ${viseme.toUpperCase()}</strong><br><br>`;
                searchHtml += `<strong>Searched for:</strong> ${searchTerms.join(', ')}<br><br>`;
                searchHtml += '<strong>Sample available morphs:</strong><br>';
                morphTargets.slice(0, 15).forEach(morph => {
                    searchHtml += `• ${morph.name} (${morph.meshName})<br>`;
                });
                if (morphTargets.length > 15) {
                    searchHtml += `<br>... and ${morphTargets.length - 15} more morphs`;
                }
                updateMorphs(searchHtml);
            }
        };

        window.runFullTest = async function() {
            if (!avatar) {
                updateStatus('❌ Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('⚡ Running full viseme test sequence...', '#ffc107');
            const visemes = ['aa', 'uw', 'th', 'iy', 'ow', 'sil'];
            
            for (let i = 0; i < visemes.length; i++) {
                const viseme = visemes[i];
                updateStatus(`⚡ Testing ${i + 1}/${visemes.length}: ${viseme.toUpperCase()}`, '#17a2b8');
                testViseme(viseme);
                await new Promise(resolve => setTimeout(resolve, 2500)); // 2.5 second delay to see changes
            }
            
            updateStatus('✅ Full test completed! Did you see facial changes?', '#d4edda');
        };

        window.updateIntensity = function(value) {
            currentIntensity = parseFloat(value);
            document.getElementById('intensity-value').textContent = value;
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.3));
                if (controls) controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.3));
                if (controls) controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 3);
                controls.target.set(0, 1.6, 0);
                controls.update();
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                const box = new window.THREE.Box3().setFromObject(avatar);
                const size = box.getSize(new window.THREE.Vector3());
                const headY = size.y * 0.9;
                camera.position.set(0, headY, 1.8);
                controls.target.set(0, headY, 0);
                controls.update();
                updateStatus('📷 Focused on head/face area');
            }
        };

    </script>
</body>
</html>