<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Visibility - GLB Render Order Fix</title>
</head>
<body>
    <h1>üî¨ Debug Visibility - Deep GLB Mesh Analysis</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">üîç Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">üîç Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">üì∑ Reset</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">üë§ Head</button>
                    <button onclick="toggleWireframe()" style="padding: 5px 10px; background: #6c757d; color: white;">üî≤ Wireframe</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 350px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa;">
                <h3>Debug Controls</h3>
                
                <div style="margin: 15px 0;">
                    <h4>üîÑ Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0; font-weight: bold;">üöÄ LOAD AVATAR</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üîß Visibility Fixes</h4>
                    <button onclick="tryBasicFix()" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; margin: 2px 0;">1Ô∏è‚É£ Basic Visibility Fix</button>
                    <button onclick="tryAdvancedFix()" style="width: 100%; padding: 8px; background: #ffc107; color: black; border: none; border-radius: 4px; margin: 2px 0;">2Ô∏è‚É£ Advanced Material Fix</button>
                    <button onclick="tryRenderOrderFix()" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; margin: 2px 0;">3Ô∏è‚É£ Render Order Fix</button>
                    <button onclick="tryNuclearOption()" style="width: 100%; padding: 8px; background: #e83e8c; color: white; border: none; border-radius: 4px; margin: 2px 0;">üí• NUCLEAR OPTION</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üîç Diagnostics</h4>
                    <button onclick="analyzeMeshByMesh()" style="width: 100%; padding: 8px; background: #6f42c1; color: white; border: none; border-radius: 4px; margin: 2px 0;">üìä Analyze Each Mesh</button>
                    <button onclick="testIndividualMesh()" style="width: 100%; padding: 8px; background: #17a2b8; color: white; border: none; border-radius: 4px; margin: 2px 0;">üéØ Show One Mesh</button>
                    <button onclick="logMaterialDetails()" style="width: 100%; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; margin: 2px 0;">üìã Log Materials</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üé≠ Test Morphs (When Face Visible)</h4>
                    <button onclick="testViseme('aa')" style="width: 100%; padding: 8px; margin: 1px 0; border: none; border-radius: 4px; background: #ffc107;">AA - MOUTH</button>
                    <button onclick="testViseme('iy')" style="width: 100%; padding: 8px; margin: 1px 0; border: none; border-radius: 4px; background: #28a745; color: white;">IY - SMILE</button>
                    <button onclick="testViseme('sil')" style="width: 100%; padding: 8px; margin: 1px 0; border: none; border-radius: 4px; background: #6c757d; color: white;">SIL - RESET</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìä Status</h4>
                    <div id="status" style="padding: 10px; background: #e9ecef; border-radius: 4px; font-size: 12px; font-weight: bold;">Loading...</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üî¨ Detailed Analysis</h4>
                    <div id="analysis" style="padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 10px; max-height: 300px; overflow-y: auto; border: 1px solid #ddd;">Waiting for avatar...</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, avatar, morphTargets = [], controls;
        let allMeshes = [];
        let wireframeMode = false;
        let currentMeshIndex = 0;

        function updateStatus(msg, color = '#e9ecef') {
            document.getElementById('status').textContent = msg;
            document.getElementById('status').style.background = color;
            console.log('STATUS:', msg);
        }

        function updateAnalysis(msg) {
            document.getElementById('analysis').innerHTML = msg;
        }

        updateStatus('Loading Three.js...', '#ffc107');

        try {
            const THREE = await import('three');
            const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
            
            window.THREE = THREE;
            window.GLTFLoader = GLTFLoader;
            window.OrbitControls = OrbitControls;

            initializeScene();

        } catch (error) {
            updateStatus('‚ùå Failed to load Three.js: ' + error.message, '#f8d7da');
        }

        function initializeScene() {
            console.log('üî¨ Initializing debug scene...');
            
            scene = new window.THREE.Scene();
            scene.background = new window.THREE.Color(0x404040);

            camera = new window.THREE.PerspectiveCamera(50, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Minimal renderer settings for debugging
            renderer = new window.THREE.WebGLRenderer({ 
                antialias: false, 
                preserveDrawingBuffer: true,
                alpha: false,
                logarithmicDepthBuffer: false
            });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = false; // Disable shadows for debugging
            renderer.sortObjects = false; // Let's see what happens without sorting

            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            controls = new window.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 1.6, 0);

            // Minimal lighting
            const ambientLight = new window.THREE.AmbientLight(0xffffff, 1.0); // Full ambient
            scene.add(ambientLight);

            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('‚úÖ Debug scene ready! Load avatar', '#d4edda');
        }

        window.loadAvatar = function() {
            updateStatus('üîÑ Loading avatar for debugging...', '#ffc107');
            
            const loader = new window.GLTFLoader();
            const glbPaths = [
                './assets/SavannahAvatar.glb',
                './dist/assets/SavannahAvatar.glb', 
                './public/assets/SavannahAvatar.glb'
            ];

            let pathIndex = 0;

            function tryLoad() {
                if (pathIndex >= glbPaths.length) {
                    updateStatus('‚ùå No GLB found', '#f8d7da');
                    return;
                }

                const path = glbPaths[pathIndex];
                updateStatus(`üì• Loading: ${path}`, '#17a2b8');

                loader.load(
                    path,
                    (gltf) => {
                        updateStatus('‚úÖ GLB loaded! NO fixes applied yet', '#28a745');
                        setupRawAvatar(gltf);
                    },
                    null,
                    (error) => {
                        pathIndex++;
                        setTimeout(tryLoad, 300);
                    }
                );
            }

            tryLoad();
        };

        function setupRawAvatar(gltf) {
            console.log('üî¨ Setting up RAW avatar (no fixes)...');

            if (avatar) scene.remove(avatar);

            avatar = gltf.scene;
            scene.add(avatar);

            // Basic scaling only
            avatar.scale.setScalar(2);
            avatar.position.y = 0;

            // Catalog all meshes WITHOUT modifying them
            catalogMeshes();

            updateStatus('üî¨ Raw avatar loaded - ready for diagnosis', '#d4edda');
        }

        function catalogMeshes() {
            allMeshes = [];
            morphTargets = [];

            console.log('üîç Cataloging meshes in raw state...');

            avatar.traverse((child) => {
                if (child.isMesh) {
                    allMeshes.push(child);
                    console.log(`Found mesh: ${child.name}`, {
                        visible: child.visible,
                        material: child.material ? child.material.type : 'none',
                        transparent: child.material ? child.material.transparent : 'N/A',
                        opacity: child.material ? child.material.opacity : 'N/A',
                        side: child.material ? child.material.side : 'N/A'
                    });

                    // Catalog morphs
                    if (child.morphTargetDictionary) {
                        const morphCount = Object.keys(child.morphTargetDictionary).length;
                        if (!child.morphTargetInfluences) {
                            child.morphTargetInfluences = new Array(morphCount).fill(0);
                        }

                        Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                            morphTargets.push({
                                name: name,
                                mesh: child,
                                meshName: child.name,
                                index: index
                            });
                        });
                    }
                }
            });

            displayRawAnalysis();
        }

        function displayRawAnalysis() {
            let html = `<strong>üî¨ RAW MESH ANALYSIS (${allMeshes.length} meshes):</strong><br><br>`;

            allMeshes.forEach((mesh, index) => {
                const name = mesh.name || `Mesh_${index}`;
                const visible = mesh.visible;
                const hasMaterial = mesh.material !== null;
                
                html += `${index + 1}. <strong>${name}</strong><br>`;
                html += `&nbsp;&nbsp;Visible: ${visible ? '‚úÖ' : '‚ùå'}<br>`;
                
                if (hasMaterial) {
                    const mat = mesh.material;
                    html += `&nbsp;&nbsp;Material: ${mat.type}<br>`;
                    html += `&nbsp;&nbsp;Transparent: ${mat.transparent}<br>`;
                    html += `&nbsp;&nbsp;Opacity: ${mat.opacity}<br>`;
                    html += `&nbsp;&nbsp;Side: ${mat.side}<br>`;
                    
                    if (mat.color) {
                        html += `&nbsp;&nbsp;Color: #${mat.color.getHexString()}<br>`;
                    }
                } else {
                    html += `&nbsp;&nbsp;‚ùå No Material<br>`;
                }
                
                html += '<br>';
            });

            html += `<strong>üé≠ Total Morphs: ${morphTargets.length}</strong><br>`;

            updateAnalysis(html);
        }

        window.tryBasicFix = function() {
            if (!avatar) return;
            
            updateStatus('üîß Applying basic visibility fix...', '#ffc107');
            
            let fixedCount = 0;
            allMeshes.forEach(mesh => {
                mesh.visible = true;
                fixedCount++;
            });
            
            updateStatus(`‚úÖ Basic fix: ${fixedCount} meshes set visible`, '#28a745');
            displayCurrentState();
        };

        window.tryAdvancedFix = function() {
            if (!avatar) return;
            
            updateStatus('üîß Applying advanced material fix...', '#ffc107');
            
            let fixedCount = 0;
            allMeshes.forEach(mesh => {
                mesh.visible = true;
                mesh.frustumCulled = false;
                
                if (mesh.material) {
                    // Clone material to avoid conflicts
                    const newMaterial = mesh.material.clone();
                    newMaterial.transparent = false;
                    newMaterial.opacity = 1.0;
                    newMaterial.alphaTest = 0;
                    newMaterial.side = window.THREE.DoubleSide;
                    newMaterial.needsUpdate = true;
                    
                    mesh.material = newMaterial;
                    fixedCount++;
                }
            });
            
            updateStatus(`‚úÖ Advanced fix: ${fixedCount} materials fixed`, '#28a745');
            displayCurrentState();
        };

        window.tryRenderOrderFix = function() {
            if (!avatar) return;
            
            updateStatus('üîß Applying render order fix...', '#ffc107');
            
            // Sort meshes by name and apply render orders
            allMeshes.forEach((mesh, index) => {
                mesh.visible = true;
                mesh.renderOrder = index; // Explicit render order
                mesh.frustumCulled = false;
                
                if (mesh.material) {
                    mesh.material.depthTest = true;
                    mesh.material.depthWrite = true;
                    mesh.material.transparent = false;
                    mesh.material.opacity = 1.0;
                    mesh.material.needsUpdate = true;
                }
            });
            
            // Enable renderer sorting
            renderer.sortObjects = true;
            
            updateStatus(`‚úÖ Render order fix applied to ${allMeshes.length} meshes`, '#28a745');
            displayCurrentState();
        };

        window.tryNuclearOption = function() {
            if (!avatar) return;
            
            updateStatus('üí• NUCLEAR OPTION - Recreating all materials...', '#dc3545');
            
            let recreatedCount = 0;
            allMeshes.forEach((mesh, index) => {
                mesh.visible = true;
                mesh.frustumCulled = false;
                mesh.renderOrder = index;
                mesh.castShadow = false;
                mesh.receiveShadow = false;
                
                if (mesh.material) {
                    // Create completely new basic material
                    const newMaterial = new window.THREE.MeshBasicMaterial({
                        color: 0xcccccc, // Light gray
                        transparent: false,
                        opacity: 1.0,
                        side: window.THREE.DoubleSide,
                        depthTest: true,
                        depthWrite: true
                    });
                    
                    // Try to preserve original color if possible
                    if (mesh.material.color) {
                        newMaterial.color.copy(mesh.material.color);
                    }
                    
                    // Try to preserve texture
                    if (mesh.material.map) {
                        newMaterial.map = mesh.material.map;
                        newMaterial.map.needsUpdate = true;
                    }
                    
                    mesh.material = newMaterial;
                    recreatedCount++;
                }
            });
            
            updateStatus(`üí• Nuclear: ${recreatedCount} materials recreated`, '#28a745');
            displayCurrentState();
        };

        function displayCurrentState() {
            let html = `<strong>üîç CURRENT STATE:</strong><br><br>`;
            
            const visibleMeshes = allMeshes.filter(m => m.visible);
            const invisibleMeshes = allMeshes.filter(m => !m.visible);
            
            html += `‚úÖ Visible: ${visibleMeshes.length}<br>`;
            html += `‚ùå Invisible: ${invisibleMeshes.length}<br><br>`;
            
            if (invisibleMeshes.length > 0) {
                html += '<strong>‚ùå Still Invisible:</strong><br>';
                invisibleMeshes.forEach(mesh => {
                    html += `&nbsp;&nbsp;‚Ä¢ ${mesh.name}<br>`;
                });
                html += '<br>';
            }
            
            html += '<strong>‚úÖ Now Visible:</strong><br>';
            visibleMeshes.slice(0, 8).forEach(mesh => {
                html += `&nbsp;&nbsp;‚Ä¢ ${mesh.name}<br>`;
            });
            
            if (visibleMeshes.length > 8) {
                html += `&nbsp;&nbsp;... +${visibleMeshes.length - 8} more<br>`;
            }

            updateAnalysis(html);
        }

        window.analyzeMeshByMesh = function() {
            if (!allMeshes.length) return;
            displayRawAnalysis();
        };

        window.testIndividualMesh = function() {
            if (!allMeshes.length) return;
            
            // Hide all meshes
            allMeshes.forEach(mesh => mesh.visible = false);
            
            // Show only current mesh
            const mesh = allMeshes[currentMeshIndex];
            mesh.visible = true;
            
            updateStatus(`üéØ Showing only: ${mesh.name} (${currentMeshIndex + 1}/${allMeshes.length})`, '#17a2b8');
            
            currentMeshIndex = (currentMeshIndex + 1) % allMeshes.length;
        };

        window.logMaterialDetails = function() {
            if (!allMeshes.length) return;
            
            console.log('üìã DETAILED MATERIAL LOG:');
            allMeshes.forEach((mesh, index) => {
                console.log(`=== MESH ${index + 1}: ${mesh.name} ===`);
                console.log('Visible:', mesh.visible);
                console.log('FrustumCulled:', mesh.frustumCulled);
                
                if (mesh.material) {
                    console.log('Material type:', mesh.material.type);
                    console.log('Transparent:', mesh.material.transparent);
                    console.log('Opacity:', mesh.material.opacity);
                    console.log('AlphaTest:', mesh.material.alphaTest);
                    console.log('Side:', mesh.material.side);
                    console.log('DepthTest:', mesh.material.depthTest);
                    console.log('DepthWrite:', mesh.material.depthWrite);
                    console.log('Color:', mesh.material.color);
                    console.log('Map:', mesh.material.map);
                } else {
                    console.log('‚ùå NO MATERIAL');
                }
                console.log('---');
            });
            
            updateStatus('üìã Material details logged to console', '#17a2b8');
        };

        window.testViseme = function(viseme) {
            if (!morphTargets.length) return;

            // Reset all morphs
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });

            if (viseme === 'sil') {
                updateStatus('‚úÖ Reset to neutral', '#d4edda');
                return;
            }

            // Simple search
            const searchTerms = {
                'aa': ['open', 'mouth', 'jaw'],
                'iy': ['smile', 'grin']
            };

            let applied = 0;
            const terms = searchTerms[viseme] || [viseme];

            terms.forEach(term => {
                morphTargets.forEach(morph => {
                    if (morph.name.toLowerCase().includes(term.toLowerCase())) {
                        morph.mesh.morphTargetInfluences[morph.index] = 1.0;
                        applied++;
                    }
                });
            });

            updateStatus(`üé≠ ${viseme.toUpperCase()}: ${applied} morphs applied`, '#d4edda');
        };

        window.toggleWireframe = function() {
            wireframeMode = !wireframeMode;
            allMeshes.forEach(mesh => {
                if (mesh.material) {
                    mesh.material.wireframe = wireframeMode;
                }
            });
            updateStatus(`üî≤ Wireframe: ${wireframeMode ? 'ON' : 'OFF'}`, '#17a2b8');
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.3));
                if (controls) controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.3));
                if (controls) controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 3);
                controls.target.set(0, 1.6, 0);
                controls.update();
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                camera.position.set(0, 2, 1.8);
                controls.target.set(0, 1.8, 0);
                controls.update();
            }
        };

    </script>
</body>
</html>