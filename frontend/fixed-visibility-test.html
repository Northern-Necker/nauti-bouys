<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Visibility Morph Test</title>
</head>
<body>
    <h1>üé≠ Fixed Visibility Morph Test - Mesh & Material Fix</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">üîç Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">üîç Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">üì∑ Reset</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">üë§ Head Focus</button>
                    <button onclick="fixMeshVisibility()" style="padding: 5px 10px; background: #e74c3c; color: white;">üîß Fix Visibility</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 350px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa;">
                <h3>Avatar Controls</h3>
                
                <div style="margin: 15px 0;">
                    <h4>üîÑ Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0; font-weight: bold;">üöÄ LOAD AVATAR</button>
                    <button onclick="analyzeMeshes()" style="width: 100%; padding: 10px; background: #6f42c1; color: white; border: none; border-radius: 4px; margin: 3px 0;">üîç Analyze Meshes</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üé≠ Test Visemes</h4>
                    <button onclick="testViseme('aa')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #ffc107; font-weight: bold;">AA - MOUTH OPEN</button>
                    <button onclick="testViseme('uw')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #17a2b8; color: white; font-weight: bold;">UW - LIPS ROUND</button>
                    <button onclick="testViseme('th')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #dc3545; color: white; font-weight: bold;">TH - TONGUE OUT</button>
                    <button onclick="testViseme('iy')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #28a745; color: white; font-weight: bold;">IY - SMILE</button>
                    <button onclick="testViseme('sil')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #6c757d; color: white; font-weight: bold;">SIL - RESET</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìä Status</h4>
                    <div id="status" style="padding: 12px; background: #e9ecef; border-radius: 4px; font-size: 13px; font-weight: bold;">Loading Three.js modules...</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üîß Mesh Analysis</h4>
                    <div id="meshes" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 11px; max-height: 250px; overflow-y: auto; border: 1px solid #ddd;">Waiting for avatar...</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, avatar, morphTargets = [], controls;
        let allMeshes = [];

        console.log('Starting visibility-fixed morph test...');

        function updateStatus(msg, color = '#e9ecef') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = msg;
            statusEl.style.background = color;
            console.log('STATUS:', msg);
        }

        function updateMeshes(msg) {
            document.getElementById('meshes').innerHTML = msg;
        }

        // Import Three.js modules
        updateStatus('Loading Three.js modules...', '#ffc107');

        try {
            const THREE = await import('three');
            const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
            
            console.log('‚úÖ Three.js modules loaded successfully!');
            updateStatus('‚úÖ Three.js loaded! Initializing scene...', '#28a745');

            // Make available globally
            window.THREE = THREE;
            window.GLTFLoader = GLTFLoader;
            window.OrbitControls = OrbitControls;

            initializeScene();

        } catch (error) {
            console.error('‚ùå Failed to load Three.js modules:', error);
            updateStatus('‚ùå Failed to load Three.js: ' + error.message, '#f8d7da');
        }

        function initializeScene() {
            console.log('Initializing scene with enhanced rendering...');
            
            // Create scene
            scene = new window.THREE.Scene();
            scene.background = new window.THREE.Color(0x404040);

            // Create camera
            camera = new window.THREE.PerspectiveCamera(50, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Create renderer with enhanced settings for GLB visibility
            renderer = new window.THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true,
                alpha: false,
                premultipliedAlpha: false
            });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = window.THREE.PCFSoftShadowMap;
            
            // Enhanced renderer settings for better material visibility
            renderer.outputColorSpace = window.THREE.SRGBColorSpace;
            renderer.toneMapping = window.THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            // Add orbit controls
            controls = new window.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.6, 0);

            // Enhanced lighting for GLB face visibility
            const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.8); // Increased ambient
            scene.add(ambientLight);

            // Key light for face
            const keyLight = new window.THREE.DirectionalLight(0xffffff, 1.2);
            keyLight.position.set(2, 3, 4);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            scene.add(keyLight);

            // Fill light from opposite side
            const fillLight = new window.THREE.DirectionalLight(0xffffff, 0.8);
            fillLight.position.set(-2, 2, 2);
            scene.add(fillLight);

            // Rim light for definition
            const rimLight = new window.THREE.DirectionalLight(0xffffff, 0.6);
            rimLight.position.set(0, 2, -3);
            scene.add(rimLight);

            // Additional front light specifically for face visibility
            const faceLight = new window.THREE.DirectionalLight(0xffffff, 0.9);
            faceLight.position.set(0, 1.8, 2);
            scene.add(faceLight);

            // Start render loop
            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('‚úÖ Scene ready! Click LOAD AVATAR', '#d4edda');
            console.log('‚úÖ Enhanced scene initialization complete');
        }

        window.loadAvatar = function() {
            if (!window.GLTFLoader || !scene) {
                updateStatus('‚ùå Three.js not ready!', '#f8d7da');
                return;
            }

            updateStatus('üîÑ Loading avatar with material fixes...', '#ffc107');
            
            const loader = new window.GLTFLoader();

            const glbPaths = [
                './assets/SavannahAvatar.glb',
                './dist/assets/SavannahAvatar.glb',
                './public/assets/SavannahAvatar.glb'
            ];

            let pathIndex = 0;

            function tryNextPath() {
                if (pathIndex >= glbPaths.length) {
                    updateStatus('‚ùå No GLB file found', '#f8d7da');
                    return;
                }

                const currentPath = glbPaths[pathIndex];
                updateStatus(`üì• Loading: ${currentPath}`, '#17a2b8');

                loader.load(
                    currentPath,
                    (gltf) => {
                        console.log('‚úÖ GLB loaded, fixing materials and visibility...');
                        updateStatus('‚úÖ GLB loaded! Fixing materials...', '#28a745');
                        setupAvatarWithFixes(gltf);
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateStatus(`üì• Loading... ${percent}%`, '#17a2b8');
                    },
                    (error) => {
                        console.warn(`Failed ${currentPath}:`, error);
                        pathIndex++;
                        setTimeout(tryNextPath, 300);
                    }
                );
            }

            tryNextPath();
        };

        function setupAvatarWithFixes(gltf) {
            console.log('Setting up avatar with material and visibility fixes...');

            if (avatar) {
                scene.remove(avatar);
            }

            avatar = gltf.scene;

            // CRITICAL: Fix materials and visibility issues
            fixAvatarMaterials(avatar);

            scene.add(avatar);

            // Apply scaling
            const box = new window.THREE.Box3().setFromObject(avatar);
            const size = box.getSize(new window.THREE.Vector3());
            const center = box.getCenter(new window.THREE.Vector3());

            let scale = 2.5;
            if (size.y < 1.0) {
                scale = 2.5 / size.y;
            }
            
            avatar.scale.setScalar(scale);
            avatar.position.copy(center).multiplyScalar(-1);
            avatar.position.y = 0;

            // Position camera for face
            const headY = size.y * scale * 0.85;
            camera.position.set(0, headY, 2.2);
            controls.target.set(0, headY, 0);
            controls.update();

            // Analyze meshes and morphs
            analyzeMeshStructure();

            updateStatus('üéâ AVATAR READY with visibility fixes!', '#d4edda');
        }

        function fixAvatarMaterials(avatarScene) {
            console.log('üîß Applying material and visibility fixes...');
            
            allMeshes = [];
            morphTargets = [];

            avatarScene.traverse((child) => {
                if (child.isMesh) {
                    allMeshes.push(child);
                    console.log(`Processing mesh: ${child.name}`, child);

                    // CRITICAL FIXES for GLB visibility issues:

                    // 1. Ensure mesh is visible
                    child.visible = true;
                    child.frustumCulled = false; // Disable frustum culling

                    // 2. Fix material issues
                    if (child.material) {
                        const material = child.material;
                        
                        // Fix common GLB material issues
                        material.transparent = false;
                        material.alphaTest = 0;
                        material.opacity = 1.0;
                        material.side = window.THREE.FrontSide;
                        
                        // Enhance material for better visibility
                        if (material.map) {
                            material.map.flipY = false; // Common GLB texture fix
                        }
                        
                        // Ensure proper lighting response
                        material.flatShading = false;
                        
                        // Force material update
                        material.needsUpdate = true;

                        // Special handling for face/skin materials
                        if (child.name.toLowerCase().includes('head') || 
                            child.name.toLowerCase().includes('face') ||
                            child.name.toLowerCase().includes('skin') ||
                            child.name.toLowerCase().includes('body')) {
                            
                            console.log(`üé≠ Applying special fixes to face/skin mesh: ${child.name}`);
                            
                            // Enhanced face material settings
                            material.metalness = 0;
                            material.roughness = 0.8;
                            
                            // Ensure face is lit properly
                            if (material.emissive) {
                                material.emissive.setHex(0x222222); // Slight self-illumination
                            }
                            
                            // Double-check visibility
                            child.renderOrder = 0; // Render normally
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }

                        console.log(`Material fixed for: ${child.name}`, {
                            transparent: material.transparent,
                            opacity: material.opacity,
                            visible: child.visible,
                            side: material.side
                        });
                    }

                    // 3. Handle morph targets
                    if (child.morphTargetDictionary) {
                        console.log(`Found morphs in: ${child.name}`, Object.keys(child.morphTargetDictionary));

                        const morphCount = Object.keys(child.morphTargetDictionary).length;
                        if (!child.morphTargetInfluences || child.morphTargetInfluences.length !== morphCount) {
                            child.morphTargetInfluences = new Array(morphCount).fill(0);
                        }

                        Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                            morphTargets.push({
                                name: name,
                                mesh: child,
                                meshName: child.name,
                                index: index
                            });
                        });
                    }

                    // 4. Force geometry updates
                    if (child.geometry) {
                        child.geometry.computeBoundingBox();
                        child.geometry.computeBoundingSphere();
                        child.geometry.computeVertexNormals();
                    }
                }
            });

            console.log(`üîß Fixed ${allMeshes.length} meshes, found ${morphTargets.length} morphs`);
        }

        function analyzeMeshStructure() {
            let meshHtml = `<strong>üîß Mesh Analysis (${allMeshes.length} meshes):</strong><br><br>`;

            allMeshes.forEach((mesh, index) => {
                const isVisible = mesh.visible;
                const hasMaterial = mesh.material !== null;
                const hasMorphs = mesh.morphTargetDictionary ? Object.keys(mesh.morphTargetDictionary).length : 0;
                
                const statusIcon = isVisible ? '‚úÖ' : '‚ùå';
                const morphInfo = hasMorphs > 0 ? ` (${hasMorphs} morphs)` : '';
                
                meshHtml += `${statusIcon} <strong>${mesh.name || `Mesh_${index}`}</strong>${morphInfo}<br>`;
                meshHtml += `&nbsp;&nbsp;Visible: ${isVisible}, Material: ${hasMaterial}<br>`;
                
                if (mesh.material) {
                    meshHtml += `&nbsp;&nbsp;Opacity: ${mesh.material.opacity}, Transparent: ${mesh.material.transparent}<br>`;
                }
                
                meshHtml += '<br>';
            });

            if (morphTargets.length > 0) {
                meshHtml += `<strong>üé≠ Morphs Found: ${morphTargets.length}</strong><br>`;
                meshHtml += 'Ready for viseme testing!';
            } else {
                meshHtml += '‚ùå No morph targets found.';
            }

            updateMeshes(meshHtml);
        }

        window.analyzeMeshes = function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('üîç Re-analyzing meshes...', '#17a2b8');
            analyzeMeshStructure();
            updateStatus('‚úÖ Mesh analysis complete!', '#d4edda');
        };

        window.fixMeshVisibility = function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('üîß Applying visibility fixes...', '#ffc107');
            console.log('üîß Manually fixing mesh visibility...');

            let fixedCount = 0;

            allMeshes.forEach(mesh => {
                // Force visibility
                mesh.visible = true;
                mesh.frustumCulled = false;
                
                if (mesh.material) {
                    mesh.material.transparent = false;
                    mesh.material.opacity = 1.0;
                    mesh.material.alphaTest = 0;
                    mesh.material.side = window.THREE.DoubleSide; // Try double-sided rendering
                    mesh.material.needsUpdate = true;
                    fixedCount++;
                }

                // Force geometry updates
                if (mesh.geometry) {
                    mesh.geometry.computeVertexNormals();
                }
            });

            updateStatus(`üîß Applied fixes to ${fixedCount} meshes`, '#28a745');
            console.log(`Applied visibility fixes to ${fixedCount} meshes`);
        };

        window.testViseme = function(viseme) {
            if (!avatar || morphTargets.length === 0) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            console.log(`Testing viseme: ${viseme}`);
            updateStatus(`üé≠ Testing ${viseme.toUpperCase()}`, '#17a2b8');

            // Reset all morphs
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });

            if (viseme === 'sil') {
                updateStatus('‚úÖ RESET TO NEUTRAL', '#d4edda');
                return;
            }

            // Enhanced search mappings
            const morphMappings = {
                'aa': ['mouth_open', 'mouthopen', 'open', 'jaw_open', 'jawopen', 'wide'],
                'uw': ['mouth_pucker', 'mouthpucker', 'pucker', 'mouth_funnel', 'mouthfunnel', 'funnel', 'round'],
                'th': ['tongue_out', 'tongueout', 'tongue', 'tip'],
                'iy': ['mouth_smile', 'mouthsmile', 'smile', 'grin', 'corners']
            };

            const searchTerms = morphMappings[viseme] || [viseme];
            let applied = 0;

            searchTerms.forEach(term => {
                morphTargets.forEach(morph => {
                    if (morph.name.toLowerCase().includes(term.toLowerCase())) {
                        morph.mesh.morphTargetInfluences[morph.index] = 1.0;
                        
                        // Force updates
                        if (morph.mesh.geometry.morphAttributes) {
                            morph.mesh.geometry.morphAttributesNeedUpdate = true;
                        }
                        morph.mesh.updateMatrix();
                        morph.mesh.updateMatrixWorld(true);
                        
                        applied++;
                        console.log(`Applied: ${morph.name} = 1.0`);
                    }
                });
            });

            updateStatus(`‚úÖ ${viseme.toUpperCase()}: ${applied} morphs applied`, '#d4edda');
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.3));
                if (controls) controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.3));
                if (controls) controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 3);
                controls.target.set(0, 1.6, 0);
                controls.update();
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                const box = new window.THREE.Box3().setFromObject(avatar);
                const size = box.getSize(new window.THREE.Vector3());
                const headY = size.y * 0.9;
                camera.position.set(0, headY, 1.5);
                controls.target.set(0, headY, 0);
                controls.update();
                updateStatus('üì∑ Focused on head area');
            }
        };

    </script>
</body>
</html>