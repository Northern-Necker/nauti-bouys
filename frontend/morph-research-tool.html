<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ActorCore GLB Morph Research Tool</title>
</head>
<body>
    <h1>üî¨ ActorCore GLB Morph Research & Fine-Tuning Tool</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">üîç Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">üîç Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">üì∑ Reset</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">üë§ Head Focus</button>
                    <button onclick="exportFineTuning()" style="padding: 5px 10px; background: #28a745; color: white;">üíæ Export Tuning</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 400px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa; max-height: 90vh; overflow-y: auto;">
                <h3>Morph Research & Fine-Tuning</h3>
                
                <div style="margin: 15px 0;">
                    <h4>üîÑ Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0; font-weight: bold;">üöÄ LOAD AVATAR</button>
                    <button onclick="analyzeAllMorphs()" style="width: 100%; padding: 10px; background: #6f42c1; color: white; border: none; border-radius: 4px; margin: 3px 0;">üîç ANALYZE ALL MORPHS</button>
                    <button onclick="showAllMorphNames()" style="width: 100%; padding: 10px; background: #dc3545; color: white; border: none; border-radius: 4px; margin: 3px 0;">üìã LIST ALL MORPH NAMES</button>
                    <button onclick="testRandomMorphs()" style="width: 100%; padding: 10px; background: #28a745; color: white; border: none; border-radius: 4px; margin: 3px 0;">üé≤ TEST RANDOM MORPHS</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üé≠ Individual Morph Testing</h4>
                    <input type="text" id="morphSearch" placeholder="Search morph names..." style="width: 100%; padding: 8px; margin: 5px 0; border: 1px solid #ccc; border-radius: 4px;" oninput="filterMorphs(this.value)">
                    <button onclick="suggestMorphsForViseme()" style="width: 100%; padding: 8px; background: #17a2b8; color: white; border: none; border-radius: 4px; margin: 5px 0;">üîÆ Suggest Morphs for Current Viseme</button>
                    <div id="morphControls" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; background: white;">
                        Morphs will appear here after loading avatar
                    </div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üéØ Viseme Fine-Tuning</h4>
                    <select id="visemeSelect" onchange="loadVisemeForTuning(this.value)" style="width: 100%; padding: 8px; margin: 5px 0;">
                        <option value="">Select viseme to tune...</option>
                        <option value="sil">SIL - Silence/Neutral</option>
                        <option value="pp">PP - Lips closed (B/M/P)</option>
                        <option value="ff">FF - Teeth on lip (F/V)</option>
                        <option value="th">TH - Tongue out</option>
                        <option value="dd">DD - Tongue to teeth (D/S/T)</option>
                        <option value="kk">KK - Back tongue (G/K)</option>
                        <option value="ch">CH - Church (CH/J/SH/ZH)</option>
                        <option value="ss">SS - Teeth (S/Z)</option>
                        <option value="nn">NN - Tongue up (N/L)</option>
                        <option value="rr">RR - Red (R sound)</option>
                        <option value="aa">AA - Father (open wide)</option>
                        <option value="e">E - Pet (mid-open)</option>
                        <option value="ih">IH - Bit (small)</option>
                        <option value="oh">OH - Boat (round)</option>
                        <option value="ou">OU - Boot (tight round)</option>
                        <option value="i">I - Beat (smile)</option>
                        <option value="o">O - Hot (very open)</option>
                        <option value="u">U - Put (small round)</option>
                    </select>
                    <button onclick="resetAllMorphs()" style="width: 100%; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; margin: 5px 0;">üîÑ Reset All Morphs</button>
                    <div id="visemeTuning" style="margin: 10px 0;">
                        Select a viseme to start fine-tuning
                    </div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìä Status</h4>
                    <div id="status" style="padding: 12px; background: #e9ecef; border-radius: 4px; font-size: 12px; font-weight: bold;">Loading...</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üî¨ Analysis Results</h4>
                    <div id="analysis" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 10px; max-height: 250px; overflow-y: auto; border: 1px solid #ddd;">Waiting for avatar...</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, avatar, morphTargets = [], controls;
        let allMorphs = [];
        let visemeConfigurations = {};
        let currentViseme = null;

        // ActorCore/Character Creator morph name patterns (research-based)
        const ACTORCORE_MORPH_PATTERNS = {
            // Mouth morphs
            mouth: ['mouth', 'lip', 'lips', 'Mouth', 'Lip'],
            jaw: ['jaw', 'Jaw'],
            tongue: ['tongue', 'Tongue'],
            // Eye morphs  
            eye: ['eye', 'Eye', 'brow', 'Brow'],
            // Cheek morphs
            cheek: ['cheek', 'Cheek'],
            // Nose morphs
            nose: ['nose', 'Nose', 'nostril'],
            // Character Creator specific
            cc_game: ['CC_Game', 'CC_Base', 'CC_'],
        };

        // PROVEN Industry Standard Viseme Mappings 
        // Based on OVR LipSync, ARKit, and Character Creator 4 research
        const INITIAL_VISEME_RESEARCH = {
            'sil': {}, // Neutral - no morphs (silence)
            'pp': {
                // BILABIAL: /p, b, m/ - Lips together
                // Industry standard ARKit: mouthClose, mouthPucker
                primary: ['mouthClose', 'mouth_close', 'Mouth_Close', 'mouthPucker', 'mouth_pucker', 'Mouth_Pucker'],
                secondary: ['close', 'press', 'together', 'lips', 'bilabial', 'viseme_PP']
            },
            'ff': {
                // LABIODENTAL: /f, v/ - Teeth on lower lip
                // Industry standard ARKit: mouthLowerDownLeft/Right
                primary: ['mouthLowerDownLeft', 'mouthLowerDownRight', 'mouth_lower_down', 'Mouth_Lower_Down', 'mouthRollLower', 'mouth_roll_lower'],
                secondary: ['bite', 'lower', 'teeth', 'fv', 'ff', 'labiodental', 'viseme_FF', 'lip_bite', 'Lip_Bite']
            },
            'th': {
                // DENTAL: /Œ∏, √∞/ - Tongue between teeth
                // Industry standard: tongueOut (ARKit)
                primary: ['tongueOut', 'tongue_out', 'Tongue_Out', 'tongueOut'],
                secondary: ['tongue', 'tip', 'dental', 'th', 'viseme_TH']
            },
            'dd': {
                // ALVEOLAR: /t, d, n, l/ - Tongue tip to alveolar ridge
                // Industry standard ARKit: Various tongue positions
                primary: ['tongueUp', 'tongue_up', 'Tongue_Up', 'mouthClose', 'mouth_close'],
                secondary: ['tongue', 'up', 'tip', 'alveolar', 'dental', 'viseme_DD', 't', 'd', 'n', 'l']
            },
            'kk': {
                // VELAR: /k, g/ - Back of tongue raised
                // Industry standard ARKit: jawOpen + tongue back
                primary: ['jawOpen', 'jaw_open', 'Jaw_Open', 'mouthOpen', 'mouth_open', 'Mouth_Open'],
                secondary: ['back', 'tongue', 'velar', 'viseme_kk', 'k', 'g', 'throat']
            },
            'ch': {
                // POSTALVEOLAR: /t É, d í,  É,  í/ - Rounded lips
                // Industry standard ARKit: mouthFunnel, mouthPucker
                primary: ['mouthFunnel', 'mouth_funnel', 'Mouth_Funnel', 'mouthPucker', 'mouth_pucker', 'Mouth_Pucker'],
                secondary: ['funnel', 'round', 'church', 'viseme_CH', 'sh', 'zh', 'ch', 'j']
            },
            'ss': {
                // ALVEOLAR FRICATIVE: /s, z/ - Teeth together, slight opening
                // Industry standard ARKit: mouthSmile (slight) + teeth together
                primary: ['mouthSmileLeft', 'mouthSmileRight', 'mouth_smile', 'Mouth_Smile', 'mouthClose'],
                secondary: ['teeth', 'narrow', 'hiss', 'viseme_SS', 's', 'z', 'smile']
            },
            'nn': {
                // NASAL: /n, ≈ã/ - Tongue up, nasal resonance
                // Industry standard ARKit: Similar to DD but with nasal quality
                primary: ['tongueUp', 'tongue_up', 'Tongue_Up', 'mouthClose', 'mouth_close'],
                secondary: ['tongue', 'up', 'nasal', 'viseme_nn', 'n', 'ng']
            },
            'rr': {
                // RHOTIC: /r/ - Tongue curled/retroflexed
                // Industry standard: Specialized tongue curl
                primary: ['tongueOut', 'tongue_out', 'mouthOpen', 'mouth_open'],
                secondary: ['curl', 'tongue', 'rhotic', 'viseme_RR', 'r', 'retroflex']
            },
            'aa': {
                // OPEN VOWEL: /…ë, √¶/ - Wide open mouth (father, cat)
                // Industry standard ARKit: jawOpen, mouthOpen
                primary: ['jawOpen', 'jaw_open', 'Jaw_Open', 'mouthOpen', 'mouth_open', 'Mouth_Open'],
                secondary: ['open', 'wide', 'ah', 'viseme_aa', 'father', 'cat']
            },
            'e': {
                // MID VOWEL: /…õ/ - Medium open (pet, bed)
                // Industry standard ARKit: Slight jaw open + slight smile
                primary: ['jawOpen', 'jaw_open', 'mouthOpen', 'mouth_open', 'mouthSmileLeft', 'mouthSmileRight'],
                secondary: ['open', 'mid', 'eh', 'viseme_E', 'pet', 'bed']
            },
            'ih': {
                // HIGH VOWEL: /…™/ - Small opening, near smile (bit, sit)
                // Industry standard ARKit: mouthSmile with small opening
                primary: ['mouthSmileLeft', 'mouthSmileRight', 'mouth_smile', 'Mouth_Smile'],
                secondary: ['open', 'small', 'ih', 'viseme_I', 'bit', 'sit', 'smile']
            },
            'oh': {
                // MID-BACK VOWEL: /o ä/ - Rounded lips (boat, go)
                // Industry standard ARKit: mouthFunnel
                primary: ['mouthFunnel', 'mouth_funnel', 'Mouth_Funnel', 'mouthPucker', 'mouth_pucker'],
                secondary: ['funnel', 'round', 'boat', 'viseme_O', 'oh', 'go']
            },
            'ou': {
                // HIGH-BACK VOWEL: /u/ - Tight lip rounding (boot, food)
                // Industry standard ARKit: mouthPucker
                primary: ['mouthPucker', 'mouth_pucker', 'Mouth_Pucker', 'mouthFunnel', 'mouth_funnel'],
                secondary: ['pucker', 'tight', 'round', 'oo', 'viseme_U', 'boot', 'food']
            },
            'i': {
                // HIGH VOWEL: /i/ - Wide smile (beat, see)
                // Industry standard ARKit: mouthSmileLeft + mouthSmileRight
                primary: ['mouthSmileLeft', 'mouthSmileRight', 'mouth_smile', 'Mouth_Smile'],
                secondary: ['smile', 'wide', 'grin', 'ee', 'beat', 'see', 'corners']
            },
            'o': {
                // BACK VOWEL: /…î/ - Open rounded (hot, dog)
                // Industry standard ARKit: jawOpen + slight funnel
                primary: ['jawOpen', 'jaw_open', 'mouthOpen', 'mouth_open', 'mouthFunnel'],
                secondary: ['open', 'round', 'hot', 'dog', 'back']
            },
            'u': {
                // HIGH-BACK VOWEL: / ä/ - Small rounding (put, book)
                // Industry standard ARKit: slight mouthPucker
                primary: ['mouthPucker', 'mouth_pucker', 'mouthFunnel', 'mouth_funnel'],
                secondary: ['pucker', 'small', 'round', 'put', 'book']
            }
        };

        function updateStatus(msg, color = '#e9ecef') {
            document.getElementById('status').textContent = msg;
            document.getElementById('status').style.background = color;
            console.log('STATUS:', msg);
        }

        function updateAnalysis(msg) {
            document.getElementById('analysis').innerHTML = msg;
        }

        updateStatus('Loading Three.js morph research tool...', '#ffc107');

        try {
            const THREE = await import('three');
            const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
            
            window.THREE = THREE;
            window.GLTFLoader = GLTFLoader;
            window.OrbitControls = OrbitControls;

            initializeScene();

        } catch (error) {
            updateStatus('‚ùå Failed to load Three.js: ' + error.message, '#f8d7da');
        }

        function initializeScene() {
            scene = new window.THREE.Scene();
            scene.background = new window.THREE.Color(0x404040);

            camera = new window.THREE.PerspectiveCamera(50, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            renderer = new window.THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true
            });
            renderer.setSize(600, 500);

            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            controls = new window.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 1.6, 0);

            // Good lighting for research
            const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const keyLight = new window.THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(2, 3, 4);
            scene.add(keyLight);

            const fillLight = new window.THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-2, 1, 2);
            scene.add(fillLight);

            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('‚úÖ Research tool ready! Load avatar to begin', '#d4edda');
        }

        window.loadAvatar = function() {
            updateStatus('üîÑ Loading ActorCore avatar for morph research...', '#ffc107');
            
            const loader = new window.GLTFLoader();
            const glbPaths = [
                './assets/SavannahAvatar.glb',
                './dist/assets/SavannahAvatar.glb', 
                './public/assets/SavannahAvatar.glb'
            ];

            let pathIndex = 0;

            function tryLoad() {
                if (pathIndex >= glbPaths.length) {
                    updateStatus('‚ùå No GLB found', '#f8d7da');
                    return;
                }

                const path = glbPaths[pathIndex];
                updateStatus(`üì• Loading: ${path}`, '#17a2b8');

                loader.load(
                    path,
                    (gltf) => {
                        updateStatus('‚úÖ Avatar loaded! Analyzing morphs...', '#28a745');
                        setupResearchAvatar(gltf);
                    },
                    null,
                    (error) => {
                        pathIndex++;
                        setTimeout(tryLoad, 300);
                    }
                );
            }

            tryLoad();
        };

        function setupResearchAvatar(gltf) {
            if (avatar) scene.remove(avatar);

            avatar = gltf.scene;

            // CRITICAL: Fix transparency issues that make meshes invisible
            let fixedCount = 0;
            avatar.traverse((child) => {
                if (child.isMesh) {
                    // Ensure mesh visibility
                    child.visible = true;
                    child.frustumCulled = false;
                    
                    if (child.material) {
                        // CRITICAL FIX: Force transparency OFF (this was the main issue)
                        child.material.transparent = false;
                        child.material.opacity = 1.0;
                        child.material.alphaTest = 0;
                        child.material.depthTest = true;
                        child.material.depthWrite = true;
                        child.material.side = window.THREE.FrontSide;
                        child.material.needsUpdate = true;
                        fixedCount++;
                        
                        console.log(`Fixed visibility for: ${child.name}`);
                    }
                }
            });

            console.log(`üîß Applied transparency fixes to ${fixedCount} meshes`);
            scene.add(avatar);

            // Scale and position
            avatar.scale.setScalar(2.5);
            avatar.position.y = 0;

            // Position camera for face research
            const headY = 2.5 * 0.85;
            camera.position.set(0, headY, 2.5);
            controls.target.set(0, headY, 0);
            controls.update();

            // Research all morphs
            researchAllMorphs();
            
            updateStatus('üî¨ Avatar ready for morph research!', '#d4edda');
        }

        function researchAllMorphs() {
            morphTargets = [];
            allMorphs = [];

            console.log('üî¨ RESEARCHING ALL MORPH TARGETS...');

            avatar.traverse((child) => {
                if (child.isMesh && child.morphTargetDictionary) {
                    console.log(`üîç Analyzing morph mesh: ${child.name}`);
                    console.log('Available morphs:', Object.keys(child.morphTargetDictionary));

                    const morphCount = Object.keys(child.morphTargetDictionary).length;
                    if (!child.morphTargetInfluences) {
                        child.morphTargetInfluences = new Array(morphCount).fill(0);
                    }

                    Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                        const morphData = {
                            name: name,
                            mesh: child,
                            meshName: child.name,
                            index: index,
                            category: categorizeMorph(name),
                            description: describeMorph(name)
                        };
                        
                        morphTargets.push(morphData);
                        allMorphs.push(morphData);
                    });
                }
            });

            console.log(`üî¨ RESEARCH COMPLETE: Found ${morphTargets.length} total morphs`);
            displayMorphResearch();
            createMorphControls();
        }

        function categorizeMorph(morphName) {
            const name = morphName.toLowerCase();
            
            // ActorCore/Character Creator specific patterns
            if (name.includes('cc_game') || name.includes('cc_base')) return 'cc-system';
            if (name.includes('mouth') || name.includes('lip')) return 'mouth';
            if (name.includes('jaw')) return 'jaw';
            if (name.includes('tongue')) return 'tongue';
            if (name.includes('eye') || name.includes('brow')) return 'eye';
            if (name.includes('cheek')) return 'cheek';
            if (name.includes('nose')) return 'nose';
            if (name.includes('smile') || name.includes('grin')) return 'expression';
            
            return 'other';
        }

        function describeMorph(morphName) {
            const name = morphName.toLowerCase();
            
            // Provide descriptions based on common patterns
            if (name.includes('open')) return 'Opens/widens feature';
            if (name.includes('close')) return 'Closes/narrows feature';
            if (name.includes('smile')) return 'Creates smile expression';
            if (name.includes('pucker')) return 'Puckers lips';
            if (name.includes('funnel')) return 'Creates funnel/round shape';
            if (name.includes('tongue')) return 'Tongue movement';
            if (name.includes('jaw')) return 'Jaw movement';
            if (name.includes('up')) return 'Moves upward';
            if (name.includes('down')) return 'Moves downward';
            if (name.includes('left')) return 'Moves left';
            if (name.includes('right')) return 'Moves right';
            
            return 'Facial feature modification';
        }

        function displayMorphResearch() {
            const categories = {};
            allMorphs.forEach(morph => {
                if (!categories[morph.category]) {
                    categories[morph.category] = [];
                }
                categories[morph.category].push(morph);
            });

            let html = `<strong>üî¨ ACTORCORE MORPH RESEARCH</strong><br><br>`;
            html += `<strong>Total Morphs: ${allMorphs.length}</strong><br><br>`;

            Object.entries(categories).forEach(([category, morphs]) => {
                html += `<strong>${category.toUpperCase()} (${morphs.length}):</strong><br>`;
                morphs.slice(0, 5).forEach(morph => {
                    html += `&nbsp;&nbsp;‚Ä¢ ${morph.name} (${morph.meshName})<br>`;
                });
                if (morphs.length > 5) {
                    html += `&nbsp;&nbsp;... +${morphs.length - 5} more<br>`;
                }
                html += '<br>';
            });

            updateAnalysis(html);
        }

        function createMorphControls() {
            const container = document.getElementById('morphControls');
            container.innerHTML = '';

            allMorphs.forEach((morph, index) => {
                const morphDiv = document.createElement('div');
                morphDiv.className = 'morph-control';
                morphDiv.style.cssText = 'margin: 8px 0; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #fafafa;';
                
                morphDiv.innerHTML = `
                    <strong>${morph.name}</strong> (${morph.meshName})<br>
                    <small style="color: #666;">${morph.description}</small><br>
                    <input type="range" min="0" max="1" step="0.05" value="0" 
                           style="width: 80%; margin: 5px 0;"
                           oninput="testSingleMorph('${morph.name}', '${morph.meshName}', this.value)">
                    <span class="morph-value" style="font-size: 12px; margin-left: 10px;">0.00</span>
                `;
                
                container.appendChild(morphDiv);
            });
        }

        window.testSingleMorph = function(morphName, meshName, value) {
            const floatValue = parseFloat(value);
            
            // Find the morph and apply it
            const morph = morphTargets.find(m => m.name === morphName && m.meshName === meshName);
            if (morph) {
                morph.mesh.morphTargetInfluences[morph.index] = floatValue;
                
                // Force geometry update
                if (morph.mesh.geometry.morphAttributes) {
                    morph.mesh.geometry.morphAttributesNeedUpdate = true;
                }
                
                // Update the display value
                event.target.nextElementSibling.textContent = floatValue.toFixed(2);
                
                console.log(`Applied: ${morphName} = ${floatValue}`);
            }
        };

        window.analyzeAllMorphs = function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }
            
            displayMorphResearch();
        };

        window.resetAllMorphs = function() {
            if (!morphTargets.length) return;
            
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });
            
            // Reset all sliders
            document.querySelectorAll('#morphControls input[type="range"]').forEach(slider => {
                slider.value = 0;
                slider.nextElementSibling.textContent = '0.00';
            });
            
            updateStatus('üîÑ All morphs reset to neutral', '#17a2b8');
        };

        window.filterMorphs = function(searchTerm) {
            const controls = document.querySelectorAll('.morph-control');
            controls.forEach(control => {
                const morphName = control.querySelector('strong').textContent.toLowerCase();
                if (morphName.includes(searchTerm.toLowerCase()) || searchTerm === '') {
                    control.style.display = 'block';
                } else {
                    control.style.display = 'none';
                }
            });
        };

        window.loadVisemeForTuning = function(viseme) {
            if (!viseme || !morphTargets.length) return;
            
            currentViseme = viseme;
            resetAllMorphs();
            
            const tuningDiv = document.getElementById('visemeTuning');
            tuningDiv.innerHTML = `
                <h5>üéØ Tuning: ${viseme.toUpperCase()}</h5>
                <p style="font-size: 12px; color: #666;">Adjust sliders above to perfect this viseme, then save your configuration.</p>
                <button onclick="applyResearchMapping('${viseme}')" style="width: 100%; padding: 8px; background: #17a2b8; color: white; border: none; border-radius: 4px; margin: 5px 0;">üîç Apply Research Mapping</button>
                <button onclick="saveCurrentViseme('${viseme}')" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; margin: 5px 0;">üíæ Save Current State</button>
            `;
        };

        window.applyResearchMapping = function(viseme) {
            if (!INITIAL_VISEME_RESEARCH[viseme]) return;
            
            resetAllMorphs();
            
            const mapping = INITIAL_VISEME_RESEARCH[viseme];
            let applied = 0;
            let testedTerms = [];
            
            // Try primary morphs first
            if (mapping.primary) {
                mapping.primary.forEach(searchTerm => {
                    testedTerms.push(searchTerm);
                    morphTargets.forEach(morph => {
                        if (morph.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            morph.mesh.morphTargetInfluences[morph.index] = 0.8;
                            applied++;
                            
                            // Update the slider
                            const controls = document.querySelectorAll('.morph-control');
                            controls.forEach(control => {
                                const nameEl = control.querySelector('strong');
                                if (nameEl.textContent === morph.name) {
                                    const slider = control.querySelector('input[type="range"]');
                                    slider.value = 0.8;
                                    slider.nextElementSibling.textContent = '0.80';
                                }
                            });
                        }
                    });
                });
            }
            
            // Try secondary terms if no primary matches
            if (applied === 0 && mapping.secondary) {
                mapping.secondary.forEach(searchTerm => {
                    testedTerms.push(searchTerm);
                    morphTargets.forEach(morph => {
                        if (morph.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            morph.mesh.morphTargetInfluences[morph.index] = 0.6;
                            applied++;
                            
                            // Update the slider
                            const controls = document.querySelectorAll('.morph-control');
                            controls.forEach(control => {
                                const nameEl = control.querySelector('strong');
                                if (nameEl.textContent === morph.name) {
                                    const slider = control.querySelector('input[type="range"]');
                                    slider.value = 0.6;
                                    slider.nextElementSibling.textContent = '0.60';
                                }
                            });
                        }
                    });
                });
            }
            
            if (applied > 0) {
                updateStatus(`üîç Applied research mapping: ${applied} morphs for ${viseme.toUpperCase()}`, '#17a2b8');
            } else {
                updateStatus(`‚ö†Ô∏è No morphs found for ${viseme.toUpperCase()}. Searched: ${testedTerms.slice(0,5).join(', ')}...`, '#fff3cd');
                console.log('Available morph names:', morphTargets.map(m => m.name));
            }
        };

        window.saveCurrentViseme = function(viseme) {
            const currentState = {};
            
            morphTargets.forEach(morph => {
                const value = morph.mesh.morphTargetInfluences[morph.index];
                if (value > 0.01) { // Only save non-zero values
                    currentState[morph.name] = {
                        value: value,
                        mesh: morph.meshName,
                        description: morph.description
                    };
                }
            });
            
            visemeConfigurations[viseme] = currentState;
            
            updateStatus(`üíæ Saved configuration for ${viseme.toUpperCase()}: ${Object.keys(currentState).length} morphs`, '#28a745');
            console.log(`Saved ${viseme}:`, currentState);
        };

        window.exportFineTuning = function() {
            const exportData = {
                timestamp: new Date().toISOString(),
                model: 'ActorCore GLB',
                totalMorphs: morphTargets.length,
                morphsByMesh: {},
                visemeConfigurations: visemeConfigurations,
                morphCatalog: allMorphs.map(m => ({
                    name: m.name,
                    mesh: m.meshName,
                    category: m.category,
                    description: m.description
                }))
            };
            
            // Group morphs by mesh for reference
            allMorphs.forEach(morph => {
                if (!exportData.morphsByMesh[morph.meshName]) {
                    exportData.morphsByMesh[morph.meshName] = [];
                }
                exportData.morphsByMesh[morph.meshName].push(morph.name);
            });
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `actorcore-morph-research-${Date.now()}.json`;
            a.click();
            
            updateStatus('üìÅ Exported morph research data!', '#28a745');
            console.log('Exported data:', exportData);
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.3));
                if (controls) controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.3));
                if (controls) controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 3);
                controls.target.set(0, 1.6, 0);
                controls.update();
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                const headY = 2.5 * 0.9;
                camera.position.set(0, headY, 1.8);
                controls.target.set(0, headY, 0);
                controls.update();
                updateStatus('üì∑ Focused on head for detailed morph analysis');
            }
        };

        window.showAllMorphNames = function() {
            if (!morphTargets.length) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            // Get all unique morph names
            const uniqueNames = [...new Set(morphTargets.map(m => m.name))].sort();
            
            let html = `<strong>üìã ALL ${uniqueNames.length} MORPH NAMES:</strong><br><br>`;
            
            // Group by common patterns
            const patterns = {
                mouth: [],
                lip: [],
                jaw: [],
                tongue: [],
                eye: [],
                brow: [],
                cheek: [],
                nose: [],
                other: []
            };
            
            uniqueNames.forEach(name => {
                const nameLower = name.toLowerCase();
                if (nameLower.includes('mouth')) patterns.mouth.push(name);
                else if (nameLower.includes('lip')) patterns.lip.push(name);
                else if (nameLower.includes('jaw')) patterns.jaw.push(name);
                else if (nameLower.includes('tongue')) patterns.tongue.push(name);
                else if (nameLower.includes('eye')) patterns.eye.push(name);
                else if (nameLower.includes('brow')) patterns.brow.push(name);
                else if (nameLower.includes('cheek')) patterns.cheek.push(name);
                else if (nameLower.includes('nose')) patterns.nose.push(name);
                else patterns.other.push(name);
            });

            Object.entries(patterns).forEach(([category, names]) => {
                if (names.length > 0) {
                    html += `<strong>${category.toUpperCase()} (${names.length}):</strong><br>`;
                    names.forEach(name => {
                        html += `&nbsp;&nbsp;‚Ä¢ ${name}<br>`;
                    });
                    html += '<br>';
                }
            });
            
            updateAnalysis(html);
            updateStatus(`üìã Listed all ${uniqueNames.length} morph names by category`, '#17a2b8');
            
            // Also log to console for easier copying
            console.log('=== ALL MORPH NAMES ===');
            uniqueNames.forEach(name => console.log(name));
        };

        window.testRandomMorphs = function() {
            if (!morphTargets.length) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            // Reset all first
            resetAllMorphs();

            // Pick 3-5 random morphs and apply them
            const shuffled = [...morphTargets].sort(() => 0.5 - Math.random());
            const selected = shuffled.slice(0, 4);
            
            let html = `<strong>üé≤ TESTING RANDOM MORPHS:</strong><br><br>`;
            
            selected.forEach(morph => {
                const value = 0.7 + Math.random() * 0.3; // 0.7 to 1.0
                morph.mesh.morphTargetInfluences[morph.index] = value;
                
                // Update slider if visible
                const controls = document.querySelectorAll('.morph-control');
                controls.forEach(control => {
                    const nameEl = control.querySelector('strong');
                    if (nameEl.textContent === morph.name) {
                        const slider = control.querySelector('input[type="range"]');
                        slider.value = value;
                        slider.nextElementSibling.textContent = value.toFixed(2);
                    }
                });
                
                html += `‚úÖ <strong>${morph.name}</strong>: ${value.toFixed(2)} (${morph.meshName})<br>`;
            });
            
            html += `<br><em>Watch the avatar - do you see any changes?</em>`;
            updateAnalysis(html);
            updateStatus(`üé≤ Applied ${selected.length} random morphs - look for changes!`, '#ffc107');
        };

        window.suggestMorphsForViseme = function() {
            if (!currentViseme || !morphTargets.length) {
                updateStatus('‚ùå Select a viseme first!', '#f8d7da');
                return;
            }
            
            // Viseme-specific suggestions based on phonetic requirements
            const visemeSuggestions = {
                'ff': {
                    keywords: ['lower', 'lip', 'teeth', 'bite', 'fv', 'labiodental', 'upper', 'mouth_lower'],
                    description: 'F/V sounds need lower lip pulled back under upper teeth'
                },
                'th': {
                    keywords: ['tongue', 'tip', 'out', 'dental', 'th'],
                    description: 'TH sounds need tongue between teeth'
                },
                'dd': {
                    keywords: ['tongue', 'up', 'alveolar', 'tip', 'roof', 't', 'd', 'n', 'roll', 'press', 'dental', 'palate', 'touch', 'raise'],
                    description: 'D/T/N sounds need tongue tip touching roof of mouth'
                },
                'kk': {
                    keywords: ['back', 'tongue', 'velar', 'k', 'g', 'throat'],
                    description: 'K/G sounds need back of tongue raised'
                },
                'ch': {
                    keywords: ['pucker', 'funnel', 'round', 'ch', 'sh', 'zh'],
                    description: 'CH/SH sounds need rounded lips'
                },
                'ss': {
                    keywords: ['teeth', 'hiss', 's', 'z', 'narrow', 'smile'],
                    description: 'S/Z sounds need teeth together with slight gap'
                },
                'nn': {
                    keywords: ['tongue', 'up', 'nasal', 'n', 'l', 'alveolar'],
                    description: 'N/L sounds need tongue tip up'
                },
                'rr': {
                    keywords: ['curl', 'tongue', 'r', 'retroflex'],
                    description: 'R sound needs tongue curled back'
                },
                'aa': {
                    keywords: ['open', 'jaw', 'mouth', 'wide', 'ah', 'down'],
                    description: 'AA needs mouth wide open'
                },
                'e': {
                    keywords: ['open', 'mid', 'mouth', 'eh'],
                    description: 'E needs medium mouth opening'
                },
                'ih': {
                    keywords: ['small', 'open', 'narrow', 'ih'],
                    description: 'IH needs small mouth opening'
                },
                'oh': {
                    keywords: ['round', 'funnel', 'oh', 'boat'],
                    description: 'OH needs rounded lips'
                },
                'ou': {
                    keywords: ['pucker', 'tight', 'round', 'oo', 'lips'],
                    description: 'OU needs tight lip rounding'
                },
                'i': {
                    keywords: ['smile', 'grin', 'corner', 'wide', 'ee'],
                    description: 'I needs wide smile'
                },
                'o': {
                    keywords: ['open', 'jaw', 'round', 'ah', 'hot'],
                    description: 'O needs open mouth with slight rounding'
                },
                'u': {
                    keywords: ['pucker', 'small', 'round', 'uh'],
                    description: 'U needs small lip rounding'
                }
            };
            
            const suggestions = visemeSuggestions[currentViseme] || { keywords: [], description: 'No specific suggestions' };
            
            let foundMorphs = [];
            let searchResults = `<strong>üîÆ Suggestions for ${currentViseme.toUpperCase()}:</strong><br>`;
            searchResults += `<em>${suggestions.description}</em><br><br>`;
            searchResults += `<strong>Searching for:</strong> ${suggestions.keywords.join(', ')}<br><br>`;
            searchResults += `<strong>Potential matches:</strong><br>`;
            
            // Search for morphs matching the keywords
            suggestions.keywords.forEach(keyword => {
                morphTargets.forEach(morph => {
                    const morphNameLower = morph.name.toLowerCase();
                    if (morphNameLower.includes(keyword.toLowerCase()) && !foundMorphs.some(f => f.name === morph.name)) {
                        foundMorphs.push(morph);
                        searchResults += `‚úÖ <strong>${morph.name}</strong> (${morph.meshName})<br>`;
                    }
                });
            });
            
            if (foundMorphs.length === 0) {
                searchResults += `<br>‚ùå No automatic matches found.<br><br>`;
                searchResults += `<strong>All available morphs for manual search:</strong><br>`;
                
                // Show all morph names for manual inspection
                const uniqueNames = [...new Set(morphTargets.map(m => m.name))];
                uniqueNames.slice(0, 20).forEach(name => {
                    searchResults += `‚Ä¢ ${name}<br>`;
                });
                if (uniqueNames.length > 20) {
                    searchResults += `... and ${uniqueNames.length - 20} more<br>`;
                }
            }
            
            updateAnalysis(searchResults);
            
            // Highlight found morphs in the controls
            if (foundMorphs.length > 0) {
                const controls = document.querySelectorAll('.morph-control');
                controls.forEach(control => {
                    const nameEl = control.querySelector('strong');
                    if (foundMorphs.some(f => f.name === nameEl.textContent)) {
                        control.style.border = '2px solid #28a745';
                        control.style.background = '#d4edda';
                    } else {
                        control.style.border = '1px solid #ddd';
                        control.style.background = '#fafafa';
                    }
                });
                
                updateStatus(`üîÆ Found ${foundMorphs.length} potential morphs for ${currentViseme.toUpperCase()}`, '#17a2b8');
            } else {
                updateStatus(`‚ö†Ô∏è No automatic matches for ${currentViseme.toUpperCase()} - try manual search`, '#fff3cd');
            }
        };

    </script>
</body>
</html>