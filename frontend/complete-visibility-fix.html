<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Visibility Fix - GLB Morph Test</title>
</head>
<body>
    <h1>üé≠ Complete Visibility Fix - All Meshes Rendering</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">üîç Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">üîç Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">üì∑ Reset</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">üë§ Head</button>
                    <button onclick="toggleWireframe()" style="padding: 5px 10px; background: #6c757d; color: white;">üî≤ Wireframe</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 350px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa;">
                <h3>Avatar Controls</h3>
                
                <div style="margin: 15px 0;">
                    <h4>üîÑ Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0; font-weight: bold;">üöÄ LOAD AVATAR</button>
                    <button onclick="forceAllVisible()" style="width: 100%; padding: 10px; background: #e74c3c; color: white; border: none; border-radius: 4px; margin: 3px 0;">üîß FORCE ALL VISIBLE</button>
                    <button onclick="analyzeMaterials()" style="width: 100%; padding: 10px; background: #6f42c1; color: white; border: none; border-radius: 4px; margin: 3px 0;">üîç Analyze Materials</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üé≠ Test Visemes (Face Now Visible)</h4>
                    <button onclick="testViseme('aa')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #ffc107; font-weight: bold;">AA - MOUTH OPEN</button>
                    <button onclick="testViseme('uw')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #17a2b8; color: white; font-weight: bold;">UW - LIPS ROUND</button>
                    <button onclick="testViseme('th')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #dc3545; color: white; font-weight: bold;">TH - TONGUE OUT</button>
                    <button onclick="testViseme('iy')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #28a745; color: white; font-weight: bold;">IY - SMILE</button>
                    <button onclick="testViseme('sil')" style="width: 100%; padding: 10px; margin: 2px 0; border: none; border-radius: 4px; background: #6c757d; color: white; font-weight: bold;">SIL - RESET</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <button onclick="runVisemeTest()" style="width: 100%; padding: 12px; background: #e83e8c; color: white; border: none; border-radius: 4px; font-weight: bold;">‚ö° AUTO TEST SEQUENCE</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìä Status</h4>
                    <div id="status" style="padding: 12px; background: #e9ecef; border-radius: 4px; font-size: 12px; font-weight: bold;">Loading...</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üîß Mesh Status</h4>
                    <div id="meshes" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 10px; max-height: 250px; overflow-y: auto; border: 1px solid #ddd;">Waiting...</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, avatar, morphTargets = [], controls;
        let allMeshes = [];
        let wireframeMode = false;

        console.log('Starting complete visibility fix test...');

        function updateStatus(msg, color = '#e9ecef') {
            document.getElementById('status').textContent = msg;
            document.getElementById('status').style.background = color;
            console.log('STATUS:', msg);
        }

        function updateMeshes(msg) {
            document.getElementById('meshes').innerHTML = msg;
        }

        // Load Three.js
        updateStatus('Loading Three.js...', '#ffc107');

        try {
            const THREE = await import('three');
            const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
            
            window.THREE = THREE;
            window.GLTFLoader = GLTFLoader;
            window.OrbitControls = OrbitControls;

            initializeScene();

        } catch (error) {
            updateStatus('‚ùå Failed to load Three.js: ' + error.message, '#f8d7da');
        }

        function initializeScene() {
            console.log('Initializing scene with optimal GLB rendering...');
            
            scene = new window.THREE.Scene();
            scene.background = new window.THREE.Color(0x404040);

            camera = new window.THREE.PerspectiveCamera(50, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Renderer optimized for GLB files
            renderer = new window.THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true,
                alpha: false,
                logarithmicDepthBuffer: true // Better depth handling
            });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = window.THREE.PCFSoftShadowMap;
            
            // Critical renderer settings for GLB visibility
            renderer.outputColorSpace = window.THREE.SRGBColorSpace;
            renderer.toneMapping = window.THREE.NoToneMapping; // Use no tone mapping for better control
            renderer.sortObjects = true; // Ensure proper render order

            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            controls = new window.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.6, 0);

            // Balanced lighting - not too bright, not too dark
            const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const mainLight = new window.THREE.DirectionalLight(0xffffff, 1.0);
            mainLight.position.set(1, 2, 3);
            mainLight.castShadow = true;
            scene.add(mainLight);

            const fillLight = new window.THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-1, 1, 1);
            scene.add(fillLight);

            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('‚úÖ Scene ready! Load avatar to begin', '#d4edda');
        }

        window.loadAvatar = function() {
            updateStatus('üîÑ Loading avatar with comprehensive fixes...', '#ffc107');
            
            const loader = new window.GLTFLoader();

            const glbPaths = [
                './assets/SavannahAvatar.glb',
                './dist/assets/SavannahAvatar.glb', 
                './public/assets/SavannahAvatar.glb'
            ];

            let pathIndex = 0;

            function tryLoad() {
                if (pathIndex >= glbPaths.length) {
                    updateStatus('‚ùå No GLB found', '#f8d7da');
                    return;
                }

                const path = glbPaths[pathIndex];
                updateStatus(`üì• Loading: ${path}`, '#17a2b8');

                loader.load(
                    path,
                    (gltf) => {
                        updateStatus('‚úÖ GLB loaded! Applying comprehensive fixes...', '#28a745');
                        setupCompleteAvatar(gltf);
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateStatus(`Loading... ${percent}%`, '#17a2b8');
                    },
                    (error) => {
                        pathIndex++;
                        setTimeout(tryLoad, 300);
                    }
                );
            }

            tryLoad();
        };

        function setupCompleteAvatar(gltf) {
            console.log('Setting up avatar with comprehensive visibility fixes...');

            if (avatar) scene.remove(avatar);

            avatar = gltf.scene;

            // COMPREHENSIVE MESH AND MATERIAL FIXES
            fixAllMeshes(avatar);

            scene.add(avatar);

            // Scaling and positioning
            const box = new window.THREE.Box3().setFromObject(avatar);
            const size = box.getSize(new window.THREE.Vector3());

            let scale = 2.5;
            if (size.y < 1.0) scale = 2.5 / size.y;
            
            avatar.scale.setScalar(scale);
            avatar.position.y = 0;

            // Camera positioning for face
            const headY = size.y * scale * 0.85;
            camera.position.set(0, headY, 2.5);
            controls.target.set(0, headY, 0);
            controls.update();

            updateStatus('üéâ AVATAR READY! All meshes should be visible', '#d4edda');
            displayMeshAnalysis();
        }

        function fixAllMeshes(avatarScene) {
            console.log('üîß Applying comprehensive mesh fixes...');
            
            allMeshes = [];
            morphTargets = [];
            let meshCount = 0;

            avatarScene.traverse((child) => {
                if (child.isMesh) {
                    allMeshes.push(child);
                    meshCount++;
                    
                    console.log(`Fixing mesh ${meshCount}: ${child.name}`);

                    // CRITICAL: Universal visibility fixes
                    child.visible = true;
                    child.frustumCulled = false;
                    child.castShadow = true;
                    child.receiveShadow = true;

                    // Handle materials comprehensively
                    if (child.material) {
                        fixMaterial(child.material, child.name);
                    }

                    // Handle geometry
                    if (child.geometry) {
                        child.geometry.computeBoundingBox();
                        child.geometry.computeBoundingSphere();
                        child.geometry.computeVertexNormals();
                    }

                    // Handle morphs
                    if (child.morphTargetDictionary) {
                        const morphCount = Object.keys(child.morphTargetDictionary).length;
                        if (!child.morphTargetInfluences) {
                            child.morphTargetInfluences = new Array(morphCount).fill(0);
                        }

                        Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                            morphTargets.push({
                                name: name,
                                mesh: child,
                                meshName: child.name,
                                index: index
                            });
                        });
                    }
                }
            });

            console.log(`üîß Fixed ${meshCount} meshes, found ${morphTargets.length} morphs`);
        }

        function fixMaterial(material, meshName) {
            // Create a copy to avoid modifying shared materials
            const fixedMaterial = material.clone();
            
            // UNIVERSAL MATERIAL FIXES
            fixedMaterial.transparent = false;
            fixedMaterial.alphaTest = 0;
            fixedMaterial.opacity = 1.0;
            fixedMaterial.depthTest = true;
            fixedMaterial.depthWrite = true;
            fixedMaterial.side = window.THREE.FrontSide; // Start with front side
            
            // Handle different material types
            if (fixedMaterial.isMeshStandardMaterial || fixedMaterial.isMeshPhysicalMaterial) {
                fixedMaterial.metalness = fixedMaterial.metalness || 0;
                fixedMaterial.roughness = fixedMaterial.roughness || 0.5;
                
                // Special handling for different mesh types
                const meshNameLower = meshName.toLowerCase();
                
                if (meshNameLower.includes('eye') || meshNameLower.includes('eyeball')) {
                    // Eyes - ensure they're glossy and visible
                    fixedMaterial.metalness = 0;
                    fixedMaterial.roughness = 0.1;
                    fixedMaterial.transparent = false;
                    console.log(`üëÅÔ∏è Applied eye material fixes to: ${meshName}`);
                    
                } else if (meshNameLower.includes('cloth') || meshNameLower.includes('shirt') || meshNameLower.includes('pants')) {
                    // Clothing - matte finish
                    fixedMaterial.metalness = 0;
                    fixedMaterial.roughness = 0.8;
                    fixedMaterial.side = window.THREE.DoubleSide; // Clothing often needs double-sided
                    console.log(`üëï Applied clothing material fixes to: ${meshName}`);
                    
                } else if (meshNameLower.includes('hair')) {
                    // Hair - special handling
                    fixedMaterial.alphaTest = 0.1; // Allow some transparency for hair
                    fixedMaterial.side = window.THREE.DoubleSide;
                    console.log(`üíá Applied hair material fixes to: ${meshName}`);
                    
                } else {
                    // Skin/face - default human skin settings
                    fixedMaterial.metalness = 0;
                    fixedMaterial.roughness = 0.6;
                    console.log(`üë§ Applied skin material fixes to: ${meshName}`);
                }
            }
            
            // Handle texture issues
            if (fixedMaterial.map) {
                fixedMaterial.map.flipY = false;
                fixedMaterial.map.needsUpdate = true;
            }
            
            // Force material update
            fixedMaterial.needsUpdate = true;
            
            console.log(`Material fixed for ${meshName}:`, {
                transparent: fixedMaterial.transparent,
                opacity: fixedMaterial.opacity,
                side: fixedMaterial.side,
                metalness: fixedMaterial.metalness,
                roughness: fixedMaterial.roughness
            });
            
            return fixedMaterial;
        }

        window.forceAllVisible = function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('üîß Forcing ALL meshes visible...', '#ffc107');
            
            let fixCount = 0;
            allMeshes.forEach(mesh => {
                mesh.visible = true;
                mesh.frustumCulled = false;
                
                if (mesh.material) {
                    // Force most aggressive visibility settings
                    mesh.material.transparent = false;
                    mesh.material.opacity = 1.0;
                    mesh.material.alphaTest = 0;
                    mesh.material.side = window.THREE.DoubleSide;
                    mesh.material.depthTest = true;
                    mesh.material.depthWrite = true;
                    mesh.material.needsUpdate = true;
                    fixCount++;
                }
            });

            updateStatus(`üîß Forced ${fixCount} meshes visible`, '#28a745');
            displayMeshAnalysis();
        };

        function displayMeshAnalysis() {
            let html = `<strong>üîß Mesh Analysis (${allMeshes.length} total):</strong><br><br>`;

            const categories = {
                visible: [],
                invisible: [],
                transparent: [],
                morphs: []
            };

            allMeshes.forEach(mesh => {
                if (!mesh.visible) {
                    categories.invisible.push(mesh.name);
                } else if (mesh.material && mesh.material.transparent) {
                    categories.transparent.push(mesh.name);
                } else {
                    categories.visible.push(mesh.name);
                }
                
                if (mesh.morphTargetDictionary && Object.keys(mesh.morphTargetDictionary).length > 0) {
                    categories.morphs.push(`${mesh.name} (${Object.keys(mesh.morphTargetDictionary).length})`);
                }
            });

            html += `‚úÖ <strong>Visible (${categories.visible.length}):</strong><br>`;
            categories.visible.slice(0, 5).forEach(name => html += `&nbsp;&nbsp;‚Ä¢ ${name}<br>`);
            if (categories.visible.length > 5) html += `&nbsp;&nbsp;... +${categories.visible.length - 5} more<br>`;

            if (categories.invisible.length > 0) {
                html += `<br>‚ùå <strong>Invisible (${categories.invisible.length}):</strong><br>`;
                categories.invisible.forEach(name => html += `&nbsp;&nbsp;‚Ä¢ ${name}<br>`);
            }

            if (categories.transparent.length > 0) {
                html += `<br>üëª <strong>Transparent (${categories.transparent.length}):</strong><br>`;
                categories.transparent.forEach(name => html += `&nbsp;&nbsp;‚Ä¢ ${name}<br>`);
            }

            if (categories.morphs.length > 0) {
                html += `<br>üé≠ <strong>With Morphs (${categories.morphs.length}):</strong><br>`;
                categories.morphs.forEach(name => html += `&nbsp;&nbsp;‚Ä¢ ${name}<br>`);
            }

            html += `<br><strong>Total Morphs: ${morphTargets.length}</strong>`;

            updateMeshes(html);
        }

        window.analyzeMaterials = function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }
            displayMeshAnalysis();
        };

        window.testViseme = function(viseme) {
            if (!avatar || morphTargets.length === 0) {
                updateStatus('‚ùå Load avatar and check for morphs!', '#f8d7da');
                return;
            }

            updateStatus(`üé≠ Testing ${viseme.toUpperCase()}`, '#17a2b8');

            // Reset all
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });

            if (viseme === 'sil') {
                updateStatus('‚úÖ Reset to neutral', '#d4edda');
                return;
            }

            // Enhanced search
            const searchMappings = {
                'aa': ['mouth_open', 'mouthopen', 'open', 'jaw_open', 'jawopen', 'wide'],
                'uw': ['mouth_pucker', 'mouthpucker', 'pucker', 'mouth_funnel', 'mouthfunnel', 'funnel'],
                'th': ['tongue_out', 'tongueout', 'tongue', 'tip'],
                'iy': ['mouth_smile', 'mouthsmile', 'smile', 'grin']
            };

            let applied = 0;
            const terms = searchMappings[viseme] || [viseme];

            terms.forEach(term => {
                morphTargets.forEach(morph => {
                    if (morph.name.toLowerCase().includes(term.toLowerCase())) {
                        morph.mesh.morphTargetInfluences[morph.index] = 1.0;
                        
                        if (morph.mesh.geometry.morphAttributes) {
                            morph.mesh.geometry.morphAttributesNeedUpdate = true;
                        }
                        
                        applied++;
                    }
                });
            });

            updateStatus(`‚úÖ ${viseme.toUpperCase()}: ${applied} morphs applied`, '#d4edda');
        };

        window.runVisemeTest = async function() {
            if (!avatar) return;

            const visemes = ['aa', 'uw', 'th', 'iy', 'sil'];
            
            for (let viseme of visemes) {
                updateStatus(`‚ö° Testing: ${viseme.toUpperCase()}`, '#17a2b8');
                testViseme(viseme);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            updateStatus('‚úÖ Auto test completed!', '#d4edda');
        };

        window.toggleWireframe = function() {
            if (!allMeshes.length) return;
            
            wireframeMode = !wireframeMode;
            allMeshes.forEach(mesh => {
                if (mesh.material) {
                    mesh.material.wireframe = wireframeMode;
                }
            });
            
            updateStatus(`üî≤ Wireframe: ${wireframeMode ? 'ON' : 'OFF'}`, '#17a2b8');
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.3));
                if (controls) controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera) {
                const direction = new window.THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.3));
                if (controls) controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 3);
                controls.target.set(0, 1.6, 0);
                controls.update();
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                const box = new window.THREE.Box3().setFromObject(avatar);
                const size = box.getSize(new window.THREE.Vector3());
                const headY = size.y * 0.9;
                camera.position.set(0, headY, 1.8);
                controls.target.set(0, headY, 0);
                controls.update();
            }
        };

    </script>
</body>
</html>