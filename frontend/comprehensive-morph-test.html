<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive GLB Morph Target Validation</title>
</head>
<body>
    <h1>üé≠ Comprehensive GLB Morph Target Validation</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">üîç Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">üîç Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">üì∑ Reset View</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">üë§ Focus Head</button>
                    <button onclick="captureScreenshot()" style="padding: 5px 10px;">üì∏ Screenshot</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 350px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa;">
                <h3>Controls & Analysis</h3>
                
                <div style="margin: 15px 0;">
                    <h4>üîÑ Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0;">Load Avatar</button>
                    <button onclick="analyzeAllMorphs()" style="width: 100%; padding: 10px; background: #17a2b8; color: white; border: none; border-radius: 4px; margin: 3px 0;">üîç Analyze All Morphs</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üé≠ Core Visemes (Enhanced)</h4>
                    <button onclick="testViseme('aa')" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #ffc107;">AA - Open Mouth (Father)</button>
                    <button onclick="testViseme('uw')" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #17a2b8; color: white;">UW - Round Lips (Boot)</button>
                    <button onclick="testViseme('th')" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #dc3545; color: white;">TH - Tongue Out</button>
                    <button onclick="testViseme('iy')" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #28a745; color: white;">IY - Smile (Beat)</button>
                    <button onclick="testViseme('ow')" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #6f42c1; color: white;">OW - Rounded (Boat)</button>
                    <button onclick="testViseme('sil')" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #6c757d; color: white;">SIL - Reset Neutral</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üöÄ Auto Tests</h4>
                    <button onclick="runBasicTest()" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #fd7e14; color: white;">Basic 5 Viseme Test</button>
                    <button onclick="runComprehensiveTest()" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #e83e8c; color: white;">All ARKit Visemes</button>
                    <button onclick="morphIntensityTest()" style="width: 100%; padding: 8px; margin: 2px 0; border: none; border-radius: 4px; background: #6f42c1; color: white;">Intensity Range Test</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üéöÔ∏è Intensity Control</h4>
                    <input type="range" id="intensity" min="0" max="1" step="0.1" value="0.8" style="width: 100%;" oninput="updateIntensity(this.value)">
                    <div>Intensity: <span id="intensity-value">0.8</span></div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìä Status</h4>
                    <div id="status" style="padding: 10px; background: #e9ecef; border-radius: 4px; font-size: 12px;">Ready to load avatar</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>üìã Analysis Results</h4>
                    <div id="analysis-results" style="padding: 10px; background: #e9ecef; border-radius: 4px; font-size: 11px; max-height: 200px; overflow-y: auto;">Load avatar to see analysis</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        let scene, camera, renderer, avatar, morphTargets = [];
        let currentIntensity = 0.8;
        let controls = null;
        let testResults = [];

        // Import Three.js
        const THREE = await import('https://unpkg.com/three@0.154.0/build/three.module.js');
        const { GLTFLoader } = await import('https://unpkg.com/three@0.154.0/examples/jsm/loaders/GLTFLoader.js');
        const { OrbitControls } = await import('https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js');

        // Enhanced morph mappings with multiple search terms and fallbacks
        const ENHANCED_MORPH_MAPPINGS = {
            'sil': {},
            'aa': {
                'primary': ['mouthOpen', 'jawOpen', 'Mouth_Open', 'Jaw_Open'],
                'secondary': ['open', 'wide', 'jaw', 'mouth_wide'],
                'intensity': 0.85
            },
            'uw': {
                'primary': ['mouthPucker', 'mouthFunnel', 'Mouth_Pucker', 'Mouth_Funnel'],
                'secondary': ['pucker', 'funnel', 'round', 'oo', 'lips'],
                'intensity': 0.9
            },
            'th': {
                'primary': ['tongueOut', 'Tongue_Out', 'tongueUp'],
                'secondary': ['tongue', 'tip', 'out'],
                'intensity': 0.9
            },
            'iy': {
                'primary': ['mouthSmile', 'Mouth_Smile', 'mouthSmileLeft', 'mouthSmileRight'],
                'secondary': ['smile', 'grin', 'happy', 'corners'],
                'intensity': 0.8
            },
            'ow': {
                'primary': ['mouthFunnel', 'mouthPucker', 'Mouth_Funnel'],
                'secondary': ['round', 'funnel', 'boat', 'circle'],
                'intensity': 0.85
            }
        };

        function updateStatus(msg, color = '#e9ecef') {
            document.getElementById('status').textContent = msg;
            document.getElementById('status').style.background = color;
            console.log(msg);
        }

        function updateAnalysis(msg) {
            document.getElementById('analysis-results').innerHTML = msg;
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);

            camera = new THREE.PerspectiveCamera(45, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 2.5);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true // For screenshots
            });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            // Add orbit controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.6, 0);

            // Professional lighting for avatar
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
            keyLight.position.set(2, 3, 4);
            keyLight.castShadow = true;
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-2, 1, 2);
            scene.add(fillLight);

            const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
            rimLight.position.set(0, 1, -3);
            scene.add(rimLight);

            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('3D scene initialized with professional lighting');
        }

        window.loadAvatar = async function() {
            if (!scene) {
                initScene();
            }

            try {
                updateStatus('Loading SavannahAvatar.glb...', '#ffc107');

                const loader = new GLTFLoader();
                const paths = [
                    './assets/SavannahAvatar.glb',
                    './dist/assets/SavannahAvatar.glb', 
                    './public/assets/SavannahAvatar.glb',
                    // Fallback online model
                    'https://models.readyplayer.me/638b9e90f3c32c854aa05d1a.glb'
                ];

                for (let i = 0; i < paths.length; i++) {
                    try {
                        updateStatus(`Trying path ${i+1}/${paths.length}: ${paths[i]}`);
                        
                        const gltf = await new Promise((resolve, reject) => {
                            loader.load(paths[i], resolve, undefined, reject);
                        });

                        setupAvatar(gltf);
                        updateStatus('‚úÖ Avatar loaded successfully!', '#d4edda');
                        return;

                    } catch (error) {
                        console.log(`Failed ${paths[i]}:`, error.message);
                        continue;
                    }
                }

                updateStatus('‚ùå Failed to load avatar from all paths', '#f8d7da');

            } catch (error) {
                updateStatus('‚ùå Error: ' + error.message, '#f8d7da');
                console.error(error);
            }
        };

        function setupAvatar(gltf) {
            // Remove existing avatar
            if (avatar) {
                scene.remove(avatar);
            }

            avatar = gltf.scene;
            scene.add(avatar);

            // Calculate bounding box for intelligent scaling
            const box = new THREE.Box3().setFromObject(avatar);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            updateStatus(`Avatar dimensions: ${size.x.toFixed(2)} √ó ${size.y.toFixed(2)} √ó ${size.z.toFixed(2)}`);

            // Intelligent scaling based on expected human proportions
            let scale = 1;
            if (size.y < 1.0) { // If shorter than 1 meter
                scale = 1.7 / size.y; // Scale to ~1.7 meters (human height)
                avatar.scale.setScalar(scale);
                updateStatus(`Applied intelligent scaling: ${scale.toFixed(2)}x`);
            }

            // Position avatar at ground level
            avatar.position.copy(center).multiplyScalar(-1);
            avatar.position.y = 0; // Ground level

            // Focus camera on head/face area
            const headY = size.y * 0.8; // Upper 80% of model (head area)
            camera.position.set(0, headY, 2);
            controls.target.set(0, headY, 0);
            controls.update();

            // Discover and categorize morph targets
            morphTargets = [];
            let totalMorphs = 0;
            let meshAnalysis = {};

            avatar.traverse((child) => {
                if (child.isMesh && child.morphTargetDictionary) {
                    console.log(`Analyzing mesh: ${child.name}`, child.morphTargetDictionary);
                    
                    if (!child.morphTargetInfluences) {
                        child.morphTargetInfluences = new Array(Object.keys(child.morphTargetDictionary).length).fill(0);
                    }

                    const meshMorphs = [];
                    Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                        morphTargets.push({
                            name: name,
                            mesh: child,
                            meshName: child.name,
                            index: index,
                            category: categorizeMorph(name)
                        });
                        meshMorphs.push(name);
                        totalMorphs++;
                    });

                    meshAnalysis[child.name] = meshMorphs;
                }
            });

            updateStatus(`‚úÖ Avatar setup complete! ${totalMorphs} morphs in ${Object.keys(meshAnalysis).length} meshes`, '#d4edda');
            
            // Display detailed analysis
            displayMorphAnalysis(meshAnalysis);
        }

        function categorizeMorph(morphName) {
            const name = morphName.toLowerCase();
            if (name.includes('mouth') || name.includes('lip')) return 'mouth';
            if (name.includes('jaw')) return 'jaw';
            if (name.includes('tongue')) return 'tongue';
            if (name.includes('cheek')) return 'cheek';
            if (name.includes('eye') || name.includes('brow')) return 'eye';
            if (name.includes('nose')) return 'nose';
            return 'other';
        }

        function displayMorphAnalysis(meshAnalysis) {
            let html = `<strong>Mesh & Morph Analysis:</strong><br><br>`;
            
            Object.entries(meshAnalysis).forEach(([meshName, morphs]) => {
                html += `<strong>${meshName}</strong> (${morphs.length} morphs):<br>`;
                
                // Group by category
                const categories = {};
                morphs.forEach(morph => {
                    const category = categorizeMorph(morph);
                    if (!categories[category]) categories[category] = [];
                    categories[category].push(morph);
                });

                Object.entries(categories).forEach(([category, categoryMorphs]) => {
                    html += `&nbsp;&nbsp;<em>${category}:</em> ${categoryMorphs.slice(0, 3).join(', ')}`;
                    if (categoryMorphs.length > 3) html += `... (+${categoryMorphs.length - 3})`;
                    html += '<br>';
                });
                html += '<br>';
            });

            updateAnalysis(html);
        }

        window.testViseme = function(viseme) {
            if (!avatar || morphTargets.length === 0) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus(`üé≠ Testing viseme: ${viseme.toUpperCase()}`, '#17a2b8');

            // Reset all morphs
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });

            if (viseme === 'sil') {
                updateStatus('‚úÖ Reset to neutral (SIL)', '#d4edda');
                return;
            }

            const config = ENHANCED_MORPH_MAPPINGS[viseme];
            if (!config) {
                updateStatus(`‚ö†Ô∏è No configuration for ${viseme}`, '#fff3cd');
                return;
            }

            let appliedMorphs = [];
            let searchResults = {
                primary: 0,
                secondary: 0,
                total: 0
            };

            // Try primary morphs first
            config.primary.forEach(searchTerm => {
                morphTargets.forEach(morph => {
                    if (morph.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                        searchTerm.toLowerCase().includes(morph.name.toLowerCase())) {
                        
                        const value = (config.intensity || 0.8) * currentIntensity;
                        morph.mesh.morphTargetInfluences[morph.index] = value;
                        
                        // Force geometry update
                        if (morph.mesh.geometry.morphAttributes) {
                            morph.mesh.geometry.morphAttributesNeedUpdate = true;
                        }
                        morph.mesh.updateMatrix();
                        morph.mesh.updateMatrixWorld(true);
                        
                        appliedMorphs.push({
                            name: morph.name,
                            value: value,
                            type: 'primary'
                        });
                        searchResults.primary++;
                        searchResults.total++;
                    }
                });
            });

            // If no primary morphs found, try secondary
            if (searchResults.primary === 0 && config.secondary) {
                config.secondary.forEach(searchTerm => {
                    morphTargets.forEach(morph => {
                        if (morph.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const value = (config.intensity || 0.8) * currentIntensity * 0.8; // Slightly lower intensity for fallback
                            morph.mesh.morphTargetInfluences[morph.index] = value;
                            
                            // Force geometry update
                            if (morph.mesh.geometry.morphAttributes) {
                                morph.mesh.geometry.morphAttributesNeedUpdate = true;
                            }
                            morph.mesh.updateMatrix();
                            morph.mesh.updateMatrixWorld(true);
                            
                            appliedMorphs.push({
                                name: morph.name,
                                value: value,
                                type: 'secondary'
                            });
                            searchResults.secondary++;
                            searchResults.total++;
                        }
                    });
                });
            }

            // Update status and log results
            if (searchResults.total > 0) {
                updateStatus(`‚úÖ ${viseme.toUpperCase()}: ${searchResults.total} morphs (${searchResults.primary} primary, ${searchResults.secondary} secondary)`, '#d4edda');
                
                let resultHtml = `<strong>Applied for ${viseme.toUpperCase()}:</strong><br>`;
                appliedMorphs.forEach(morph => {
                    resultHtml += `${morph.type === 'primary' ? 'üéØ' : 'üîÑ'} ${morph.name}: ${morph.value.toFixed(2)}<br>`;
                });
                updateAnalysis(resultHtml);

                console.log(`${viseme} results:`, appliedMorphs);
            } else {
                updateStatus(`‚ö†Ô∏è No morphs found for ${viseme.toUpperCase()}`, '#fff3cd');
                
                let availableHtml = `<strong>No matches for ${viseme.toUpperCase()}</strong><br><br>Available morphs:<br>`;
                morphTargets.slice(0, 10).forEach(morph => {
                    availableHtml += `‚Ä¢ ${morph.name}<br>`;
                });
                if (morphTargets.length > 10) {
                    availableHtml += `... and ${morphTargets.length - 10} more`;
                }
                updateAnalysis(availableHtml);
            }
        };

        window.analyzeAllMorphs = function() {
            if (!avatar || morphTargets.length === 0) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('üîç Analyzing all available morphs...', '#17a2b8');

            const categories = {
                mouth: [],
                jaw: [],
                tongue: [],
                cheek: [],
                eye: [],
                nose: [],
                other: []
            };

            morphTargets.forEach(morph => {
                const category = categorizeMorph(morph.name);
                categories[category].push(morph.name);
            });

            let html = `<strong>Complete Morph Inventory (${morphTargets.length}):</strong><br><br>`;
            
            Object.entries(categories).forEach(([category, morphs]) => {
                if (morphs.length > 0) {
                    html += `<strong>${category.toUpperCase()} (${morphs.length}):</strong><br>`;
                    morphs.forEach(morph => {
                        html += `&nbsp;&nbsp;‚Ä¢ ${morph}<br>`;
                    });
                    html += '<br>';
                }
            });

            // Suggest potential viseme matches
            html += `<strong>Viseme Matching Analysis:</strong><br>`;
            Object.entries(ENHANCED_MORPH_MAPPINGS).forEach(([viseme, config]) => {
                if (config.primary) {
                    let matches = 0;
                    config.primary.forEach(searchTerm => {
                        morphTargets.forEach(morph => {
                            if (morph.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                matches++;
                            }
                        });
                    });
                    html += `${viseme.toUpperCase()}: ${matches > 0 ? '‚úÖ' : '‚ùå'} ${matches} potential matches<br>`;
                }
            });

            updateAnalysis(html);
            updateStatus('‚úÖ Morph analysis complete!', '#d4edda');
        };

        window.runBasicTest = async function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('üöÄ Running basic 5-viseme test...', '#ffc107');
            const visemes = ['aa', 'uw', 'th', 'iy', 'ow'];
            
            for (let i = 0; i < visemes.length; i++) {
                updateStatus(`Testing ${i + 1}/5: ${visemes[i].toUpperCase()}`, '#17a2b8');
                testViseme(visemes[i]);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }
            
            // Reset to neutral
            testViseme('sil');
            updateStatus('‚úÖ Basic test completed!', '#d4edda');
        };

        window.runComprehensiveTest = async function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('üöÄ Running comprehensive ARKit viseme test...', '#ffc107');
            const allVisemes = Object.keys(ENHANCED_MORPH_MAPPINGS);
            
            testResults = [];
            
            for (let i = 0; i < allVisemes.length; i++) {
                const viseme = allVisemes[i];
                updateStatus(`Testing ${i + 1}/${allVisemes.length}: ${viseme.toUpperCase()}`, '#17a2b8');
                
                // Reset first
                testViseme('sil');
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Apply viseme
                testViseme(viseme);
                
                // Analyze result
                const result = analyzeCurrentMorphState(viseme);
                testResults.push(result);
                
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            displayTestResults();
            updateStatus(`‚úÖ Comprehensive test complete! ${testResults.filter(r => r.hasChanges).length}/${testResults.length} visemes working`, '#d4edda');
        };

        function analyzeCurrentMorphState(viseme) {
            const activeMorphs = morphTargets.filter(morph => 
                morph.mesh.morphTargetInfluences[morph.index] > 0.01
            );
            
            const maxInfluence = Math.max(...morphTargets.map(morph => 
                morph.mesh.morphTargetInfluences[morph.index] || 0
            ));

            return {
                viseme: viseme,
                activeMorphs: activeMorphs.length,
                maxInfluence: maxInfluence,
                hasChanges: maxInfluence > 0.05,
                morphNames: activeMorphs.map(m => m.name)
            };
        }

        function displayTestResults() {
            const working = testResults.filter(r => r.hasChanges).length;
            const total = testResults.length;
            
            let html = `<strong>üìä Test Results Summary</strong><br><br>`;
            html += `Success Rate: <strong>${working}/${total}</strong> (${Math.round(working/total*100)}%)<br><br>`;
            
            testResults.forEach(result => {
                const status = result.hasChanges ? '‚úÖ' : '‚ùå';
                html += `${status} ${result.viseme.toUpperCase()}: ${result.activeMorphs} morphs, max: ${result.maxInfluence.toFixed(2)}<br>`;
            });
            
            updateAnalysis(html);
        }

        window.morphIntensityTest = async function() {
            if (!avatar) {
                updateStatus('‚ùå Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus('üéöÔ∏è Testing intensity ranges...', '#ffc107');
            const testViseme = 'aa';
            const intensities = [0.2, 0.4, 0.6, 0.8, 1.0];
            
            for (let intensity of intensities) {
                currentIntensity = intensity;
                document.getElementById('intensity-value').textContent = intensity.toFixed(1);
                document.getElementById('intensity').value = intensity;
                
                updateStatus(`Testing intensity: ${intensity} (${testViseme.toUpperCase()})`, '#17a2b8');
                testViseme('sil');
                await new Promise(resolve => setTimeout(resolve, 300));
                testViseme(testViseme);
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            updateStatus('‚úÖ Intensity test completed!', '#d4edda');
        };

        window.updateIntensity = function(value) {
            currentIntensity = parseFloat(value);
            document.getElementById('intensity-value').textContent = value;
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera && controls) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.2));
                controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera && controls) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.2));
                controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 2.5);
                controls.target.set(0, 1.6, 0);
                controls.update();
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                const box = new THREE.Box3().setFromObject(avatar);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                const headY = size.y * 0.8; // Focus on head area
                camera.position.set(0, headY, 1.5);
                controls.target.set(0, headY, 0);
                controls.update();
                
                updateStatus('üì∑ Focused on head/face area');
            }
        };

        window.captureScreenshot = function() {
            if (!renderer) return;
            
            const canvas = renderer.domElement;
            const dataURL = canvas.toDataURL('image/png');
            
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = `morph-test-${Date.now()}.png`;
            a.click();
            
            updateStatus('üì∏ Screenshot captured!', '#d4edda');
        };

        // Initialize scene on load
        initScene();
        updateStatus('Ready! Click "Load Avatar" to begin comprehensive testing');
    </script>
</body>
</html>