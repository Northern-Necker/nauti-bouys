<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed GLB Morph Test</title>
    <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.154.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <h1>🎭 Fixed GLB Morph Test - Visual Validation</h1>
    
    <div style="display: flex; gap: 20px; margin: 20px;">
        <!-- 3D Viewer -->
        <div style="flex: 1;">
            <div style="border: 2px solid #007bff; padding: 10px; background: #f8f9fa;">
                <h3>3D Avatar View</h3>
                <div id="scene" style="width: 600px; height: 500px; border: 1px solid #ccc; background: #333;"></div>
                <div style="margin: 10px 0;">
                    <button onclick="zoomIn()" style="padding: 5px 10px;">🔍 Zoom In</button>
                    <button onclick="zoomOut()" style="padding: 5px 10px;">🔍 Zoom Out</button>
                    <button onclick="resetCamera()" style="padding: 5px 10px;">📷 Reset View</button>
                    <button onclick="focusOnHead()" style="padding: 5px 10px;">👤 Focus Head</button>
                    <button onclick="captureScreenshot()" style="padding: 5px 10px;">📸 Screenshot</button>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div style="width: 350px;">
            <div style="border: 2px solid #28a745; padding: 15px; background: #f8f9fa;">
                <h3>Controls & Tests</h3>
                
                <div style="margin: 15px 0;">
                    <h4>🔄 Setup</h4>
                    <button onclick="loadAvatar()" style="width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 4px; margin: 3px 0; font-size: 14px; font-weight: bold;">🚀 LOAD AVATAR</button>
                    <button onclick="testAllVisemes()" style="width: 100%; padding: 8px; background: #17a2b8; color: white; border: none; border-radius: 4px; margin: 3px 0;">🎭 Test All Visemes</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>🎭 Test Visemes</h4>
                    <button onclick="testViseme('aa')" style="width: 100%; padding: 10px; margin: 3px 0; border: none; border-radius: 4px; background: #ffc107; font-weight: bold;">AA - Open Mouth Wide</button>
                    <button onclick="testViseme('uw')" style="width: 100%; padding: 10px; margin: 3px 0; border: none; border-radius: 4px; background: #17a2b8; color: white;">UW - Round Lips</button>
                    <button onclick="testViseme('th')" style="width: 100%; padding: 10px; margin: 3px 0; border: none; border-radius: 4px; background: #dc3545; color: white;">TH - Tongue Out</button>
                    <button onclick="testViseme('iy')" style="width: 100%; padding: 10px; margin: 3px 0; border: none; border-radius: 4px; background: #28a745; color: white;">IY - Smile Wide</button>
                    <button onclick="testViseme('ow')" style="width: 100%; padding: 10px; margin: 3px 0; border: none; border-radius: 4px; background: #6f42c1; color: white;">OW - Round Open</button>
                    <button onclick="testViseme('sil')" style="width: 100%; padding: 10px; margin: 3px 0; border: none; border-radius: 4px; background: #6c757d; color: white;">SIL - Reset Neutral</button>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>🎚️ Intensity</h4>
                    <input type="range" id="intensity" min="0" max="1" step="0.1" value="1.0" style="width: 100%;" oninput="updateIntensity(this.value)">
                    <div>Intensity: <span id="intensity-value">1.0</span> (MAX for visibility)</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>📊 Status</h4>
                    <div id="status" style="padding: 12px; background: #e9ecef; border-radius: 4px; font-size: 13px; font-weight: bold;">Click LOAD AVATAR to begin</div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4>📋 Test Results</h4>
                    <div id="results" style="padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 11px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd;">Load avatar first</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, avatar, morphTargets = [], controls;
        let currentIntensity = 1.0; // Start at max intensity for visibility
        let testResults = [];

        function updateStatus(msg, color = '#e9ecef') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = msg;
            statusElement.style.background = color;
            statusElement.style.color = color === '#e9ecef' ? '#333' : '#fff';
            console.log('STATUS:', msg);
        }

        function updateResults(msg) {
            document.getElementById('results').innerHTML = msg;
        }

        function initScene() {
            console.log('Initializing Three.js scene...');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);

            // Create camera
            camera = new THREE.PerspectiveCamera(45, 600/500, 0.1, 1000);
            camera.position.set(0, 1.6, 3);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true
            });
            renderer.setSize(600, 500);
            renderer.shadowMap.enabled = true;

            const sceneDiv = document.getElementById('scene');
            sceneDiv.innerHTML = '';
            sceneDiv.appendChild(renderer.domElement);

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1.6, 0);

            // Enhanced lighting for facial features
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
            keyLight.position.set(2, 3, 4);
            keyLight.castShadow = true;
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-2, 1, 2);
            scene.add(fillLight);

            // Start animation loop
            function animate() {
                requestAnimationFrame(animate);
                if (controls) controls.update();
                renderer.render(scene, camera);
            }
            animate();

            updateStatus('✅ 3D scene initialized successfully!', '#d4edda');
            console.log('Scene initialization complete');
        }

        window.loadAvatar = function() {
            updateStatus('⏳ Loading avatar... Please wait', '#ffc107');
            console.log('Starting avatar load process...');
            
            if (!scene) {
                initScene();
            }

            if (typeof THREE.GLTFLoader === 'undefined') {
                updateStatus('❌ GLTFLoader not available! Check script loading.', '#f8d7da');
                console.error('THREE.GLTFLoader is undefined');
                return;
            }

            const loader = new THREE.GLTFLoader();
            
            const paths = [
                './assets/SavannahAvatar.glb',
                './dist/assets/SavannahAvatar.glb',
                './public/assets/SavannahAvatar.glb',
                'https://models.readyplayer.me/638b9e90f3c32c854aa05d1a.glb'
            ];

            let currentPath = 0;

            function tryNextPath() {
                if (currentPath >= paths.length) {
                    updateStatus('❌ Failed to load any GLB file. Check file paths.', '#f8d7da');
                    console.error('All GLB paths failed');
                    return;
                }

                const path = paths[currentPath];
                updateStatus(`📥 Trying path ${currentPath + 1}/${paths.length}: ${path}`, '#17a2b8');
                console.log(`Attempting to load: ${path}`);

                loader.load(
                    path,
                    (gltf) => {
                        console.log('GLB loaded successfully!', gltf);
                        updateStatus('✅ GLB loaded! Setting up avatar...', '#28a745');
                        setupAvatar(gltf);
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateStatus(`📥 Loading... ${percent}%`, '#17a2b8');
                    },
                    (error) => {
                        console.warn(`Failed to load ${path}:`, error);
                        currentPath++;
                        setTimeout(tryNextPath, 500);
                    }
                );
            }

            tryNextPath();
        };

        function setupAvatar(gltf) {
            console.log('Setting up avatar...');
            
            // Remove existing avatar
            if (avatar) {
                scene.remove(avatar);
                console.log('Removed existing avatar');
            }

            avatar = gltf.scene;
            scene.add(avatar);

            // Calculate size and apply intelligent scaling
            const box = new THREE.Box3().setFromObject(avatar);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            console.log('Avatar dimensions:', size);
            console.log('Avatar center:', center);

            // Apply aggressive scaling to ensure visibility
            let scale = 1;
            if (size.y < 1.5) { // If shorter than 1.5 units
                scale = 2.0 / size.y; // Scale to 2 units tall for maximum visibility
                avatar.scale.setScalar(scale);
                console.log(`Applied scaling: ${scale}x`);
            }

            // Position avatar
            avatar.position.copy(center).multiplyScalar(-1);
            avatar.position.y = 0;
            console.log('Avatar positioned at:', avatar.position);

            // Focus camera on head area  
            const headY = size.y * scale * 0.8;
            camera.position.set(0, headY, 2.5);
            controls.target.set(0, headY, 0);
            controls.update();
            console.log(`Camera focused on head at Y: ${headY}`);

            // Find and catalog morph targets
            morphTargets = [];
            let meshCount = 0;

            avatar.traverse((child) => {
                if (child.isMesh) {
                    meshCount++;
                    if (child.morphTargetDictionary) {
                        console.log(`Found morph mesh: ${child.name}`, Object.keys(child.morphTargetDictionary));
                        
                        // Initialize morphTargetInfluences
                        const morphCount = Object.keys(child.morphTargetDictionary).length;
                        if (!child.morphTargetInfluences || child.morphTargetInfluences.length !== morphCount) {
                            child.morphTargetInfluences = new Array(morphCount).fill(0);
                        }

                        Object.entries(child.morphTargetDictionary).forEach(([name, index]) => {
                            morphTargets.push({
                                name: name,
                                mesh: child,
                                meshName: child.name,
                                index: index
                            });
                        });
                    }
                }
            });

            updateStatus(`🎉 SUCCESS! Avatar loaded with ${morphTargets.length} morphs in ${meshCount} meshes`, '#d4edda');
            
            displayMorphInfo();
            console.log('Avatar setup complete!');
            console.log(`Total morph targets: ${morphTargets.length}`);
        }

        function displayMorphInfo() {
            let html = `<strong>✅ Avatar Ready!</strong><br><br>`;
            html += `<strong>Morph Targets Found: ${morphTargets.length}</strong><br><br>`;
            
            if (morphTargets.length > 0) {
                // Group morphs by mesh
                const morphsByMesh = {};
                morphTargets.forEach(morph => {
                    if (!morphsByMesh[morph.meshName]) {
                        morphsByMesh[morph.meshName] = [];
                    }
                    morphsByMesh[morph.meshName].push(morph.name);
                });

                html += '<strong>Available Morphs:</strong><br>';
                Object.entries(morphsByMesh).forEach(([meshName, morphs]) => {
                    html += `<br><em>${meshName}:</em><br>`;
                    morphs.slice(0, 5).forEach(morph => {
                        html += `• ${morph}<br>`;
                    });
                    if (morphs.length > 5) {
                        html += `... +${morphs.length - 5} more<br>`;
                    }
                });
                
                html += '<br><strong>Ready to test visemes! 🎭</strong>';
            } else {
                html += '❌ No morph targets found in this model.';
            }

            updateResults(html);
        }

        window.testViseme = function(viseme) {
            if (!avatar || morphTargets.length === 0) {
                updateStatus('❌ Load avatar first!', '#f8d7da');
                return;
            }

            updateStatus(`🎭 Testing ${viseme.toUpperCase()}...`, '#17a2b8');
            console.log(`Testing viseme: ${viseme}`);

            // Reset all morphs first
            morphTargets.forEach(morph => {
                morph.mesh.morphTargetInfluences[morph.index] = 0;
            });

            if (viseme === 'sil') {
                updateStatus('✅ Reset to neutral (SIL)', '#d4edda');
                console.log('Reset all morphs to neutral');
                return;
            }

            // Enhanced search terms for better matching
            const searchMappings = {
                'aa': ['mouth_open', 'mouthopen', 'open', 'jaw_open', 'jawopen', 'wide', 'ah'],
                'uw': ['mouth_pucker', 'mouthpucker', 'pucker', 'mouth_funnel', 'mouthfunnel', 'funnel', 'round', 'oo'],
                'th': ['tongue_out', 'tongueout', 'tongue', 'tip'],
                'iy': ['mouth_smile', 'mouthsmile', 'smile', 'grin', 'corners'],
                'ow': ['mouth_funnel', 'mouthfunnel', 'funnel', 'round', 'boat']
            };

            const searchTerms = searchMappings[viseme] || [viseme];
            let appliedMorphs = [];
            let appliedCount = 0;

            // Search for matching morphs
            searchTerms.forEach(term => {
                morphTargets.forEach(morph => {
                    const morphNameLower = morph.name.toLowerCase();
                    const termLower = term.toLowerCase();
                    
                    if (morphNameLower.includes(termLower) || termLower.includes(morphNameLower)) {
                        const value = currentIntensity;
                        morph.mesh.morphTargetInfluences[morph.index] = value;
                        
                        // Force geometry update
                        if (morph.mesh.geometry.morphAttributes) {
                            morph.mesh.geometry.morphAttributesNeedUpdate = true;
                        }
                        morph.mesh.updateMatrix();
                        morph.mesh.updateMatrixWorld(true);
                        
                        appliedMorphs.push({
                            name: morph.name,
                            value: value
                        });
                        appliedCount++;
                        console.log(`Applied morph: ${morph.name} = ${value}`);
                    }
                });
            });

            // Update status and results
            if (appliedCount > 0) {
                updateStatus(`✅ ${viseme.toUpperCase()}: ${appliedCount} morphs applied at ${currentIntensity}`, '#d4edda');
                
                let resultHtml = `<strong>Applied for ${viseme.toUpperCase()}:</strong><br><br>`;
                appliedMorphs.forEach(morph => {
                    resultHtml += `✅ ${morph.name}: ${morph.value.toFixed(2)}<br>`;
                });
                updateResults(resultHtml);
            } else {
                updateStatus(`⚠️ No morphs found for ${viseme.toUpperCase()}`, '#fff3cd');
                
                let availableHtml = `<strong>❌ No matches for ${viseme.toUpperCase()}</strong><br><br>`;
                availableHtml += '<strong>Available morphs:</strong><br>';
                morphTargets.slice(0, 15).forEach(morph => {
                    availableHtml += `• ${morph.name}<br>`;
                });
                if (morphTargets.length > 15) {
                    availableHtml += `<br>... and ${morphTargets.length - 15} more`;
                }
                updateResults(availableHtml);
            }
        };

        window.testAllVisemes = async function() {
            if (!avatar) {
                updateStatus('❌ Load avatar first!', '#f8d7da');
                return;
            }

            const visemes = ['aa', 'uw', 'th', 'iy', 'ow', 'sil'];
            updateStatus('🚀 Testing all visemes...', '#ffc107');
            
            for (let i = 0; i < visemes.length; i++) {
                updateStatus(`Testing ${i + 1}/${visemes.length}: ${visemes[i].toUpperCase()}`, '#17a2b8');
                testViseme(visemes[i]);
                await new Promise(resolve => setTimeout(resolve, 2000)); // 2 second delay to see changes
            }
            
            updateStatus('✅ All viseme tests completed!', '#d4edda');
        };

        window.updateIntensity = function(value) {
            currentIntensity = parseFloat(value);
            document.getElementById('intensity-value').textContent = value;
        };

        // Camera controls
        window.zoomIn = function() {
            if (camera && controls) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(0.3));
                controls.update();
            }
        };

        window.zoomOut = function() {
            if (camera && controls) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                camera.position.add(direction.multiplyScalar(-0.3));
                controls.update();
            }
        };

        window.resetCamera = function() {
            if (camera && controls) {
                camera.position.set(0, 1.6, 3);
                controls.target.set(0, 1.6, 0);
                controls.update();
            }
        };

        window.focusOnHead = function() {
            if (avatar && camera && controls) {
                const box = new THREE.Box3().setFromObject(avatar);
                const size = box.getSize(new THREE.Vector3());
                const headY = size.y * 0.85;
                camera.position.set(0, headY, 2);
                controls.target.set(0, headY, 0);
                controls.update();
                updateStatus('📷 Focused on head area');
            }
        };

        window.captureScreenshot = function() {
            if (!renderer) return;
            
            const canvas = renderer.domElement;
            const dataURL = canvas.toDataURL('image/png');
            
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = `morph-test-${Date.now()}.png`;
            a.click();
            
            updateStatus('📸 Screenshot captured!', '#d4edda');
        };

        // Initialize on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                initScene();
                updateStatus('Ready! Click LOAD AVATAR to begin testing', '#d1ecf1');
            }, 100);
        });

        // Add some debug info
        console.log('Fixed morph test initialized');
        console.log('THREE.js version:', THREE.REVISION);
    </script>
</body>
</html>